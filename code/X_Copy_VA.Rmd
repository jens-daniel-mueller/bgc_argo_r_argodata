---
title: "Temporal data coverage"
author: "David Stappard & Jens Daniel Müller"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r set_options_global, include=FALSE}

knitr::opts_chunk$set(warning = FALSE, message = FALSE)

```

# Task

Load existing bgc_data.rds file and align profiles to a common vertical pattern.

```{r loading_libraries, include=FALSE}

library(tidyverse)
library(argodata)
library(lubridate)
# The Gibbs SeaWater (GSW) Oceanographic Toolbox of TEOS-10 https://www.teos-10.org/
# used to derive depth from profile latitude and pressure
library(gsw)
library(gridExtra)
```

```{r set_updata_root_directory, include=FALSE}

path_argo <- '/nfs/kryo/work/datasets/ungridded/3d/ocean/floats/bgc_argo'
path_argo_preprocessed <- paste0(path_argo, "/preprocessed_bgc_data")
path_basin_mask <- "/nfs/kryo/work/datasets/reccap2/"
path_emlr_utilities <- "/nfs/kryo/work/jenmueller/emlr_cant/utilities/files/"

# /nfs/kryo/work/datasets/ungridded/3d/ocean/floats/bgc_argo/preprocessed_bgc_data


```

# Load data

## BGC-Argo data
```{r load_preprocessed_data}

full_load = 0

if (full_load == 0) {
bgc_metadata <-
  read_rds(file = paste0(path_argo_preprocessed, "/bgc_metadata_small.rds"))
bgc_data <-
  read_rds(file = paste0(path_argo_preprocessed, "/bgc_data_small.rds"))
bgc_merge <-
  read_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_small.rds"))
}

if (full_load == 1) {
bgc_metadata <-
  read_rds(file = paste0(path_argo_preprocessed, "/bgc_metadata.rds"))
bgc_data <-
  read_rds(file = paste0(path_argo_preprocessed, "/bgc_data.rds"))
bgc_merge <-
  read_rds(file = paste0(path_argo_preprocessed, "/bgc_merge.rds"))

# Create a temp working data sets with just a few profile while working on initial development
working_sample_file_1 <- 'aoml/5904172/profiles/SD5904172_020.nc'
working_sample_file_2 <- 'aoml/1901466/profiles/SD1901466_120.nc'
working_sample_file_3 <- 'aoml/5901458/profiles/SD5901458_186.nc'

bgc_metadata_small <- bgc_metadata[bgc_metadata$file %in% c(working_sample_file_1, working_sample_file_2, working_sample_file_3), ]
bgc_data_small <- bgc_data[bgc_data$file %in% c(working_sample_file_1, working_sample_file_2, working_sample_file_3), ]
bgc_merge_small <- bgc_merge[bgc_merge$file %in% c(working_sample_file_1, working_sample_file_2, working_sample_file_3), ]

# write reduced size files
bgc_metadata_small %>% 
  write_rds(file = paste0(path_argo_preprocessed, "/bgc_metadata_small.rds"))
bgc_data_small %>% 
  write_rds(file = paste0(path_argo_preprocessed, "/bgc_data_small.rds"))
bgc_merge_small %>% 
  write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_small.rds"))
}

```

## Create (update) depth field from pressure amd latitude
```{r derive_depth}

# Use Gibb's Seawater based on TEOS-10.0
bgc_merge <- bgc_merge %>%
  mutate(depth = gsw_z_from_p(pres_adjusted, lat)*-1.0)

```

## Create alignment function based on spline functin 
```{r derive_depth}

# The depth that we want to align data items to
target_depth <- list(2.5, seq(from = 5, to = 400, by = 5), seq(from = 425, to = 1000, by = 25), seq(from = 1050, to = 2000, by = 50))
target_depth_num <- as.numeric(unlist(target_depth))
target_depth_df <- tibble(target_depth_num)

vertical_align <- function(x, y){
      spline(unlist(x), unlist(y), method='natural', xout=target_depth_num)$y
    }

vertical_align_1 <- function(x, y){
      spline(unlist(x), unlist(y), method='natural', xout=target_depth_num)
    }

vertical_align_2 <- function(x, y){
      spline(x, y, method='natural', xout=target_depth_num)
    }

vertical_align_3 <- function(x, y){
      spline(x, y, method='natural', xout=target_depth_num)$y
    }


```

## Build working data frame with the source profile details
```{r assemble_source_profiles}

# attrib_type
#   1 = salinity
#   2 = salinity error
#   3 = temperature
#   4 = temperature error
#   5 = pH
#   6 = pH error

# create bgc_merge_vert_data based on salinity
bgc_merge_vert_data <-bgc_merge %>% 
  filter(psal_adjusted_qc %in% c(1, 8)) %>% 
  select(
    file, 
    n_prof, 
    depth, 
    attrib = psal_adjusted
    ) %>%
  mutate(attrib_type = 1, .before = depth)

# Add to bgc_merge_vert_data salinity error
bgc_merge_vert_data <- rbind(bgc_merge_vert_data, bgc_merge %>%
  filter(psal_adjusted_qc %in% c(1, 8)) %>%
  select(
    file,
    n_prof,
    depth,
    attrib = psal_adjusted_error
    ) %>%
  mutate(attrib_type = 2, .before = depth))

# Add to bgc_merge_vert_data temperature
bgc_merge_vert_data <- rbind(bgc_merge_vert_data, bgc_merge %>%
  filter(temp_adjusted_qc %in% c(1, 8)) %>%
  select(
    file,
    n_prof,
    depth,
    attrib = temp_adjusted
    ) %>%
  mutate(attrib_type = 3, .before = depth))

# Add to bgc_merge_vert_data temperature error
bgc_merge_vert_data <- rbind(bgc_merge_vert_data, bgc_merge %>%
  filter(temp_adjusted_qc %in% c(1, 8)) %>%
  select(
    file,
    n_prof,
    depth,
    attrib = temp_adjusted_error
    ) %>%
  mutate(attrib_type = 4, .before = depth))

# Add to bgc_merge_vert_data pH
bgc_merge_vert_data <- rbind(bgc_merge_vert_data, bgc_merge %>%
  filter(ph_in_situ_total_adjusted_qc %in% c(1, 8)) %>%
  select(
    file,
    n_prof,
    depth,
    attrib = ph_in_situ_total_adjusted
    ) %>%
  mutate(attrib_type = 5, .before = depth))

# Add to bgc_merge_vert_data pH error
bgc_merge_vert_data <- rbind(bgc_merge_vert_data, bgc_merge %>%
  filter(ph_in_situ_total_adjusted_qc %in% c(1, 8)) %>%
  select(
    file,
    n_prof,
    depth,
    attrib = ph_in_situ_total_adjusted_error
    ) %>%
  mutate(attrib_type = 6, .before = depth))

# Calculate the profile limits
bgc_profile_limits <- bgc_merge_vert_data %>% 
  group_by(file, n_prof, attrib_type) %>%
  summarise(
    profile_min = min(depth), 
    profile_max = max(depth)
    )

# For each profile min depth determine the target level that matches
target_rows = nrow(target_depth_df)
depth_diff <- vapply(bgc_profile_limits$profile_min, function(x) x-target_depth_df$target_depth_num, numeric(target_rows))
depth_indx <- apply(abs(depth_diff), 2, which.min)
bgc_profile_limits <- cbind(bgc_profile_limits, target_range_min = depth_indx)
# For each profile max depth determine the target level that matches
depth_diff <- vapply(bgc_profile_limits$profile_max, function(x) x-target_depth_df$target_depth_num, numeric(target_rows))
depth_indx <- apply(abs(depth_diff), 2, which.min)
bgc_profile_limits <- cbind(bgc_profile_limits, target_range_max = depth_indx)

# For each profile limit what are the actual depth limit
bgc_profile_limits <- bgc_profile_limits %>%
  select (
    file,
    n_prof,
    attrib_type,
    target_range_min,
    target_range_max
  ) %>%
  mutate (
    target_depth_min = target_depth_num[target_range_min],
    target_depth_max = target_depth_num[target_range_max]
  )


# This format summaries by profile 
#   salinity = combination of depth_1 and attrib_1
#   salinity error = combination of depth_2 and attrib_2
#   temperature = combination of depth_3 and attrib_3
#   temperature error = combination of depth_4 and attrib_4
#   pH = combination of depth_5 and attrib_5
#   pH error = combination of depth_6 and attrib_6
file_base_profiles <- bgc_merge_vert_data %>%
  pivot_wider(names_from = attrib_type, values_from = c(depth, attrib), values_fn = list)




file_base_profiles %>%
  select(
    file,
    n_prof
  ) %>%
  mutate(
    sal_va = vertical_align_1(depth_1, attrib_1)
  ) 




file_base_profiles %>%
  select(
    file,
    n_prof
  ) %>%
  pivot_longer(cols = vertical_align_2(file_base_profiles$depth_1, file_base_profiles$attrib_1)$y
  ) 




# vertical_aligned_profiles_salinity <- tibble(
#   file = file_base_profiles$file, 
#   n_prof = file_base_profiles$n_prof, 
#   attrib_type = 1, 
#   depth <- target_depth_df, 
#   attrib = vertical_align(file_base_profiles$depth_1, file_base_profiles$attrib_1)
#   )
# colnames(vertical_aligned_profiles_salinity)[4] = "depth"

# vertical_align_1(file_base_profiles$depth_1, file_base_profiles$attrib_1)$x
# 
# 
# file_base_profiles %>%
#   filter (file == 'aoml/5904172/profiles/SD5904172_020.nc') %>%
#   mutate(
#     vertical_align(depth_1, attrib_1)
#   ) %>%
#   filter(!is.null(depth_1))
#   
# 
# file_base_profiles %>%
#   select (
#     file, 
#     n_prof,
#     depth_input = depth_1, 
#     attrib_input = attrib_1
#   ) %>%
#   mutate (
#     
#   )
# 
# transmute(.data = file_base_profiles,
#         va = vertical_align(depth_1, attrib_1))
# 
# 
# 
# vertical_align_1(file_base_profiles$depth_1, file_base_profiles$attrib_1)










# colnames(bgc_merge)
# 
# bgc_merge_toplevel <- bgc_merge[bgc_merge$n_levels == 1, ]
# 
# bgc_merge_toplevel
# XX <- bgc_merge_toplevel[bgc_merge_toplevel$depth > 8 & bgc_merge_toplevel$depth < 11, ]





# bgc_merge_vert_data %>% select(depth) %>% group_by(file, n_prof, attrib_type)
# 
# bgc_merge_vert_data %>%
#   filter(
#     n_prof == 1, 
#     attrib_type ==1) %>%
#   select (
#     file, 
#     n_prof, 
#     attrib_type
#   ) %>%
#   mutate(
#     va_attrib = vertical_align(
#       depth,
#       attrib)
#   )
# 
# 
# 
# bgc_merge_vert_data %>%
#   filter(
#     n_prof == 1, 
#     attrib_type ==1) %>%
#   select(
#     spline(
#       bgc_merge_vert_data$depth,
#       bgc_merge_vert_data$attrib,
#       method='natural',
#       xout=target_depth_num
#       )
#   )
# 
# 
# spDepth <- bgc_merge_vert_data %>% filter (attrib_type == 1) %>% select(depth)
# spAttrib <- bgc_merge_vert_data %>% filter (attrib_type == 1) %>% select(attrib)
# spDepth[, 2] <- bgc_merge_vert_data %>% filter (attrib_type == 2) %>% select(depth)
# spAttrib[, 2] <- bgc_merge_vert_data %>% filter (attrib_type == 2) %>% select(attrib)
# 
# spData <- bgc_merge_vert_data %>% filter (attrib_type == 1) %>% select(depth, attrib)
# 
# sp <- function(x, y){
#       spline(unlist(x), unlist(y), method='natural', xout=target_depth_num)$y
#     }
# 
# sp1 <- function(x, y){
#       spline(x, y, method='natural', xout=target_depth_num)$y
#     }
# 
# bgc_merge_vert_data %>% 
#   group_by (file, n_prof, attrib_type) %>% 
#   select(
#     sp1(bgc_merge_vert_data$depth,
#     bgc_merge_vert_data$attrib)
#   )
# 


```


## For each float profile align to a common set of vertical depths
```{r align_vertical_depths}

#   #-------------------------------------------------------------------------------------------
#   # *** This method will not work for volume of data involved here!! ***
#   #-------------------------------------------------------------------------------------------
# 
# 
# 
# # The depth that we want to align data items to
# target_depth <- list(2.5, seq(from = 5, to = 400, by = 5), seq(from = 425, to = 1000, by = 25), seq(from = 1050, to = 2000, by = 50))
# target_depth_num <- as.numeric(unlist(target_depth))
# 
# start_time <- Sys.time()
# #for(i in 1:nrow(bgc_metadata)) {
# for(i in 1:100) {
#   
# 
#   # Get the details for the specific file and profile we are interested in
#   working_file <- unlist(bgc_metadata[i, "file"])
#   working_profile <- unlist(bgc_metadata[i, "n_prof"])
#   bgc_merge_single <- bgc_merge[bgc_merge$file == working_file & bgc_merge$n_prof == working_profile, ]
#   
#   #-------------------------------------------------------------------------------------------
#   # Salinity
#   #-------------------------------------------------------------------------------------------
#   # Get salinity data
#   source_dat_depth <- unlist(bgc_merge_single %>% 
#   filter(file == working_file & n_prof == working_profile & psal_adjusted_qc %in% c(1, 8)) %>% 
#   select(
#     depth
#     ))
#   source_dat <- unlist(bgc_merge_single %>% 
#   filter(file == working_file & n_prof == working_profile & psal_adjusted_qc %in% c(1, 8)) %>% 
#   select(
#     psal_adjusted
#     ))
#   source_dat_error <- unlist(bgc_merge_single %>% 
#   filter(file == working_file & n_prof == working_profile & psal_adjusted_qc %in% c(1, 8)) %>% 
#   select(
#     psal_adjusted_error
#     ))
# 
#   # Determine range for target data set
#   min_depth = min(source_dat_depth)
#   max_depth = max(source_dat_depth)
#   target_limit1 = which.min(abs(target_depth_num - min_depth))
#   target_limit2 = which.min(abs(target_depth_num - max_depth))
#   
#   if (target_limit2 > target_limit1) {
#     
#     target_for_profile = target_depth_num[target_limit1:target_limit2]
#     # Derive salinity target profile
#     # Derive core salinity
#     tmp=spline(source_dat_depth, source_dat, method='natural', xout=target_for_profile)
#     target_sal=tmp$y
#     tmp=spline(source_dat_depth, source_dat_error, method='natural', xout=target_for_profile)
#     target_sal_error=tmp$y
#   
#     # target_for_profile, target_sal, target_sal_error
#   
#   } #if
#   
#   #-------------------------------------------------------------------------------------------
#   # Temperature
#   #-------------------------------------------------------------------------------------------
#   # Get temperature data
#   source_dat_depth <- unlist(bgc_merge_single %>% 
#   filter(file == working_file & n_prof == working_profile & temp_adjusted_qc %in% c(1, 8)) %>% 
#   select(
#     depth
#     ))
#   source_dat <- unlist(bgc_merge_single %>% 
#   filter(file == working_file & n_prof == working_profile & temp_adjusted_qc %in% c(1, 8)) %>% 
#   select(
#     temp_adjusted
#     ))
#   source_dat_error <- unlist(bgc_merge_single %>% 
#   filter(file == working_file & n_prof == working_profile & temp_adjusted_qc %in% c(1, 8)) %>% 
#   select(
#     temp_adjusted_error
#     ))
# 
#   # Determine range for target data set
#   min_depth = min(source_dat_depth)
#   max_depth = max(source_dat_depth)
#   target_limit1 = which.min(abs(target_depth_num - min_depth))
#   target_limit2 = which.min(abs(target_depth_num - max_depth))
#   
#   if (target_limit2 > target_limit1) {
#     
#     target_for_profile = target_depth_num[target_limit1:target_limit2]
# 
#     # Derive salinity target profile
#     # Derive core salinity
#     tmp=spline(source_dat_depth, source_dat, method='natural', xout=target_for_profile)
#     target_temp=tmp$y
#     tmp=spline(source_dat_depth, source_dat_error, method='natural', xout=target_for_profile)
#     target_temp_error=tmp$y
#     
#     # target_for_profile, target_temp, target_temp_error
#   } #if
#     
#   #-------------------------------------------------------------------------------------------
#   # pH
#   #-------------------------------------------------------------------------------------------
#   # Get temperature data
#   source_dat_depth <- unlist(bgc_merge_single %>% 
#   filter(file == working_file & n_prof == working_profile & ph_in_situ_total_adjusted_qc %in% c(1, 8)) %>% 
#   select(
#     depth
#     ))
#   source_dat <- unlist(bgc_merge_single %>% 
#   filter(file == working_file & n_prof == working_profile & ph_in_situ_total_adjusted_qc %in% c(1, 8)) %>% 
#   select(
#     ph_in_situ_total_adjusted
#     ))
#   source_dat_error <- unlist(bgc_merge_single %>% 
#   filter(file == working_file & n_prof == working_profile & ph_in_situ_total_adjusted_qc %in% c(1, 8)) %>% 
#   select(
#     ph_in_situ_total_adjusted_error
#     ))
# 
#   # Determine range for target data set
#   min_depth = min(source_dat_depth)
#   max_depth = max(source_dat_depth)
#   target_limit1 = which.min(abs(target_depth_num - min_depth))
#   target_limit2 = which.min(abs(target_depth_num - max_depth))
#   
#   if (target_limit2 > target_limit1) {
#     
#     target_for_profile = target_depth_num[target_limit1:target_limit2]
# 
#     # Derive salinity target profile
#     # Derive core salinity
#     tmp=spline(source_dat_depth, source_dat, method='natural', xout=target_for_profile)
#     target_pH=tmp$y
#     tmp=spline(source_dat_depth, source_dat_error, method='natural', xout=target_for_profile)
#     target_pH_error=tmp$y
#   
#     # target_for_profile, target_pH, target_pH_error
#     
#   } #if
#   
# } #for
# end_time <- Sys.time()
# end_time - start_time


```


## derive vertical aligned profiles for sample with depth plots
```{r align_common_depth_sample}

# data_type = 1 = Salinity, 2 = Temperature, 3 = pH
data_type = 1
# spline_method = 1 = determine new x and apply before calling spline function,
#                 2 = call spline with "full" new x and apply new range after call
spline_method = 2

working_sample_file_1 <- 'aoml/5904172/profiles/SD5904172_020.nc'

# Get data based on data_type
if (data_type == 1) {
  source_data_depth <- unlist(bgc_merge %>% 
  filter(psal_adjusted_qc %in% c(1, 8) & file == working_sample_file_1) %>% 
  select(
    depth
    ))
  source_data <- unlist(bgc_merge %>% 
  filter(psal_adjusted_qc %in% c(1, 8) & file == working_sample_file_1) %>% 
  select(
    psal_adjusted
    ))
  y_label = "salinity (psu)"
}
if (data_type == 2) {
  source_data_depth <- unlist(bgc_merge %>% 
  filter(temp_adjusted_qc %in% c(1, 8) & file == working_sample_file_1) %>% 
  select(
    depth
    ))
  source_data <- unlist(bgc_merge %>% 
  filter(temp_adjusted_qc %in% c(1, 8) & file == working_sample_file_1) %>% 
  select(
    temp_adjusted
    ))
  y_label = "temperature (°C)"
}
if (data_type == 3) {
  source_data_depth <- unlist(bgc_merge %>% 
  filter(ph_in_situ_total_adjusted_qc %in% c(1, 8) & file == working_sample_file_1) %>% 
  select(
    depth
    ))
  source_data <- unlist(bgc_merge %>% 
  filter(ph_in_situ_total_adjusted_qc %in% c(1, 8) & file == working_sample_file_1) %>% 
  select(
    ph_in_situ_total_adjusted
    ))
  y_label = "pH"
}

# Determine target depths
min_depth = min(source_data_depth)
max_depth = max(source_data_depth)
target_limit1 = which.min(abs(target_depth_num - min_depth))
target_limit2 = which.min(abs(target_depth_num - max_depth))
target_for_profile = target_depth_num[target_limit1:target_limit2]

if (spline_method == 1) {
  tmp=spline(source_data_depth, source_data, method='natural', xout=target_for_profile)
  target_data=tmp$y
}
if (spline_method == 2) {
  spline_xx = target_depth_num
  target_data=vertical_align(source_data_depth, source_data)
}

if (spline_method == 2) {
  target_data = target_data[target_limit1:target_limit2]
}

source_dp <- tibble(source_data_depth, source_data)
target_dp <- tibble(target_for_profile, target_data)

## Depth plot of derived vertical aligned (red) profile against source (black) profile as lines
p1 <- ggplot()+
  geom_line(data=source_dp, aes(x=source_data_depth, y=source_data), color = "black", linewidth=0.5, linetype=1)+
  geom_line(data=target_dp, aes(x=target_for_profile, y=target_data), color = "red", linewidth=0.5, linetype=1)+
  #set up the asthetics
  labs(x= "depth (m)", y = y_label)+
  #reverse depth so it starts at zero
  scale_x_reverse()+
  #put the y axis labes on the opposite side so when its flipped it will appear at top
  scale_y_continuous(position="right")+
  #this is how you reverse the look and order or the coordinates for the graph
  coord_flip()

## Depth plot of source profile as black circles
p2 <- ggplot()+
  geom_point(data=source_dp, aes(x=source_data_depth, y=source_data), color = "black")+
  #set up the asthetics
  labs(x= "", y = y_label)+
  #reverse depth so it starts at zero
  scale_x_reverse()+
  #put the y axis labes on the opposite side so when its flipped it will appear at top
  scale_y_continuous(position="right")+
  #this is how you reverse the look and order or the coordinates for the graph
  coord_flip()

## Depth plot of derived vertical aligned profile as red circles
p3 <- ggplot()+
  geom_point(data=target_dp, aes(x=target_for_profile, y=target_data), color = "red")+
  #set up the asthetics
  labs(x= "", y = y_label)+
  #reverse depth so it starts at zero
  scale_x_reverse()+
  #put the y axis labes on the opposite side so when its flipped it will appear at top
  scale_y_continuous(position="right")+
  #this is how you reverse the look and order or the coordinates for the graph
  coord_flip()

grid.arrange(p1, p2, p3, nrow = 1)
rm(p1, p2, p3)

```

## Remove BGC data

```{r remove_bgc_data}

#rm(list = ls(pattern = 'bgc_'))

```
