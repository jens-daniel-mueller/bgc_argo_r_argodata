---
title: "Load BGC-Argo Data"
author: "David Stappard, Pasqualina Vonlanthen & Jens Daniel MÃ¼ller"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r set_options_global, include=FALSE}

knitr::opts_chunk$set(warning = FALSE, message = FALSE)

```

# Task
Load BGC data for analysis 


```{r loading_libraries, include=FALSE}

library(tidyverse)
# remotes::install_github('ArgoCanada/argodata')
library(argodata)
library(ggplot2)
library(lubridate)
# install.packages('sf')
# install.packages("oce")
library(sf)
library(oce)
# install.packages('ggspatial')
# devtools::install_github("MikkoVihtakari/ggOceanMapsData")
# devtools::install_github("MikkoVihtakari/ggOceanMaps")
library(ggspatial)
library(ggOceanMaps)
```

```{r set_updata_root_directory, include=FALSE}

path_argo <- '/nfs/kryo/work/datasets/ungridded/3d/ocean/floats/bgc_argo'
path_argo_preprocessed <- paste0(path_argo, "/preprocessed_bgc_data")
```

## Set load options

Determine if files are refreshed from dac or cache directory is used. 
Are metadata, temperature, salinity and BGC property year files renewed?
Are the consolidated all year files created from the individual year files?

```{r set_load_options}

# opt_refresh_cache
#   FALSE = do not refresh cache.
#   TRUE  = refresh cache. (any none zero value will force a refresh)
opt_refresh_cache = FALSE

# opt_refresh_years_temp, opt_refresh_years_psal, opt_refresh_years_doxy, opt_refresh_years_nitrate, opt_refresh_years_pH, opt_refresh_years_metadata
#   FALSE = do not refresh the yearly files. (any value <> 1 will omit annual refresh)
#   TRUE  = refresh yearly files for given parameter.
#   year to be refreshed are set by opt_min_year and opt_max_year
opt_refresh_years_temp = TRUE
opt_refresh_years_psal = TRUE
opt_refresh_years_doxy = TRUE
opt_refresh_years_nitrate = TRUE
opt_refresh_years_pH = TRUE
opt_refresh_years_metadata = TRUE
opt_min_year = 2013
opt_max_year = 2023

# opt_consolidate_temp, opt_consolidate_psal, opt_consolidate_doxy, opt_consolidate_nitrate, opt_consolidate_pH, opt_consolidate_metadata
# Yearly files must have already been created!
#   FALSE = do not build consolidated file from previously written yearly files. (any value <> 1 will omit consolidation)
#   TRUE  = build consolidated file from previously written yearly files for given parameter.
#   year to be included in the consolidation are set by opt_min_year and opt_max_year
opt_consolidate_temp = TRUE
opt_consolidate_psal = TRUE
opt_consolidate_psal = TRUE
opt_consolidate_doxy = TRUE
opt_consolidate_nitrate = TRUE
opt_consolidate_pH = TRUE
opt_consolidate_metadata = TRUE

# opt_summary_files
# consolidated files must have already been created!
#   FALSE = do not build summary files from previously written consolidated files. (any value <> 1 will omit A and AB files)
#   TRUE  = build summary files from previously written consolidated files.
opt_summary_files = TRUE

# opt_review_mode
# if set (1) the processing will take place in a sub-directory opt_review_dir and only process 10 days of profiles per year to reduce size
# of output and processing time
opt_review_mode = FALSE
opt_review_dir = "/review_mode"

#if (opt_review_mode) {
#  path_argo_preprocessed <- paste0(path_argo_core, "/preprocessed_data", opt_review_dir)
#}
  
# opt_qc_only
# Avoids reprocessing files and ensures qc summary plots are created from a previous run!
#   FALSE = carry out reprocessing based on options set above and create QC summaries.
#   TRUE  = do NOT reprocessing files and just create QC summaries from previous loads.
opt_qc_only = FALSE

# opt_n_prof_sel
# The selection criteria that is used against n_prof, here set to 1
# Description of n_prof usage is provided at https://argo.ucsd.edu/data/data-faq/version-3-profile-files/ the next two lines are from that page.
#     The main Argo CTD profile is stored in N_PROF=1. All other parameters (including biogeochemical parameters) that are measured 
#     with the same vertical sampling scheme and at the same location and time as the main Argo CTD profile are also stored in N_PROF=1.
opt_n_prof_sel = 1

```


## Set cache directory 

Directory where the core-Argo profile files are stored. Either use the cached files or force a refresh from dac (long process)

```{r set_cache_directory}

if (!opt_qc_only) {

  # set cache directory
  argo_set_cache_dir(cache_dir = path_argo)
  
  # check cache directory
  argo_cache_dir()
  
  # check argo mirror
  argo_mirror()
  
  # age argument: age of the cached files to update in hours (Inf means always use the cached file, and -Inf means always download from the server) 
  # ex: max_global_cache_age = 5 updates files that have been in the cache for more than 5 hours, max_global_cache_age = 0.5 updates 
  # files that have been in the cache for more than 30 minutes, etc.
  if (opt_refresh_cache){
    argo_update_global(max_global_cache_age = -Inf)  
    argo_update_data(max_data_cache_age = -Inf)
  } else {
    argo_update_global(max_global_cache_age = Inf)  
    argo_update_data(max_data_cache_age = Inf)
  }
}

```

## Load by year

Builds yearly files for temperature, salinity, BGC properties and metadata that can be consolidated in the next code chunk (consolidate_into_allyears). Load in the synthetic (merged core and bgc) index files (uses the data stored on the ifremer server by default), keeping only delayed-mode data.

### File Types

A core-Argo profile contains the CTD sensor parameters (pressure, temperature, salinity) that are measured with the same vertical sampling scheme and at the same location and time. Additional parameters from other sensors are stored in the b-Argo profile files.

A b-Argo profile contains all the parameters from a float, except the core-Argo parameters temperature, pressure, and salinity. A float that performs only CTD measurements does not have a b-Argo file. The vertical level `PRES` is the simple and unambiguous link between the parameters in the core-Argo and b-Argo files. The same `PRES` is recorded in the core-Argo and b-Argo files. PRES is the only parameter duplicated in core-Argo and b-Argo profile files.

To facilitate the use of BGC-Argo data, the regional data centers merge each b-Argo file with its corresponding core-Argo file into one synthetic (s-Argo) file. The goal of a simplified s-Argo file is to co-locate as many BGC observations as possible while preserving the character of the sampling pattern, i.e., sample interval, number of samples, and approximate pressure locations. Data come from the single c- and b-Argo files. The synthetic pressure axis is constructed from the BGC sampling levels from each cycle. This means that there is no fixed vertical grid for all floats and all cycles.

The co-location takes different vertical attachments of BGC sensors into account by displacing the pressure location, which is not the case in the c- and b-files. The single-cycle s--file profiles contain all the c-file parameter observations in their original location and resolution.

The adjusted pressure parameter (`pres_adjusted`) is only available in the core- and s-Argo profile files. The variables `profile_pres_qc`, `pres_adjusted`, and `pres_adjusted_error`, are not duplicated in the b-Argo files.

### Data Modes

Delayed-mode data are denoted by `data_mode = 'D'`, and are quality-checked by PIs, who apply any necessary adjustments. For the core CTD data, delayed-mode data is generally available 12 months after the transmission of raw data, because the raw data is usually of good quality. Their delayed-mode assessment involves evaluation of the long-term sensor stability, which typically requires a float record of 12 months. Incorrect QC flag attribution and erroneous raw data not flagged during real-time procedures are corrected in delayed-mode.

Delayed-mode BGC data may be available as early as 5-6 cycles after initial data transmission as the raw data are typically unfit for scientific usage. Adjustments significantly increase the accuracy of these data. In b- and s-Argo profile files, the variable `parameter_data_mode` indicates the mode of each parameter. Biogeochemical parameters in the same file may receive their delayed-mode adjustments at different times.

*Synthetic files info: <https://archimer.ifremer.fr/doc/00445/55637/80863.pdf>*

*Argo User Manual: <https://archimer.ifremer.fr/doc/00187/29825/86414.pdf>*


```{r load_core_by_year}
#------------------------------------------------------------------------------
# Important - file are loaded for the given year processed and the files written to disk.
#------------------------------------------------------------------------------
if (!opt_qc_only) {

  for (target_year in opt_min_year:opt_max_year) {
    # for manual testing of the loop
    # target_year <- 2017
  
    # if updating any year files it will be based on the initial index file core_index
    if (opt_refresh_years_temp | opt_refresh_years_psal | opt_refresh_years_doxy | opt_refresh_years_nitrate | opt_refresh_years_pH | opt_refresh_years_metadata)
    {
      # if working in reiew mode only consider first 10 days of the year
      if (opt_review_mode) {
        bgc_index <- argo_global_synthetic_prof() %>% 
          argo_filter_data_mode(data_mode = 'delayed') %>% 
          argo_filter_date(date_min = paste0(target_year, "-01-01"),
                           date_max = paste0(target_year, "-01-10"))
      } else {
        bgc_index <- argo_global_synthetic_prof() %>% 
          argo_filter_data_mode(data_mode = 'delayed') %>% 
          argo_filter_date(date_min = paste0(target_year, "-01-01"),
                           date_max = paste0(target_year, "-12-31"))
      }
    }
  
    # if temp or psal are being updated get the profile data
    if (opt_refresh_years_temp | opt_refresh_years_psal | opt_refresh_years_doxy | opt_refresh_years_nitrate | opt_refresh_years_pH)
    {
      # read in the profiles (takes a while)
      bgc_data_yr <- argo_prof_levels(
        path = bgc_index,
        vars =
          c(
            'PRES_ADJUSTED',
            'PRES_ADJUSTED_QC',
            'PRES_ADJUSTED_ERROR',
            'PSAL_ADJUSTED',
            'PSAL_ADJUSTED_QC',
            'PSAL_ADJUSTED_ERROR',
            'TEMP_ADJUSTED',
            'TEMP_ADJUSTED_QC',
            'TEMP_ADJUSTED_ERROR',
            'DOXY_ADJUSTED',
            'DOXY_ADJUSTED_QC',
            'DOXY_ADJUSTED_ERROR',
            'NITRATE_ADJUSTED',
            'NITRATE_ADJUSTED_QC',
            'NITRATE_ADJUSTED_ERROR',
            'PH_IN_SITU_TOTAL_ADJUSTED',
            'PH_IN_SITU_TOTAL_ADJUSTED_QC',
            'PH_IN_SITU_TOTAL_ADJUSTED_ERROR'
          ),
        quiet = TRUE
      )
      
      # see option section above for rational of why we want n_prof = 1 profiles
      bgc_data_yr <- bgc_data_yr%>%
      filter(n_prof == opt_n_prof_sel)
      
      # if necessary make summary data frame.
      if (!exists("bgc_measure_summary"))
      {
        columns = c("year","measure","measure_order","measure_qc","count_measures") 
        bgc_measure_summary = data.frame(matrix(nrow = 0, ncol = length(columns))) 
        colnames(bgc_measure_summary) = columns
      }
      
      # Ensure no N/A qc flags
      bgc_data_yr["pres_adjusted_qc"][is.na(bgc_data_yr["pres_adjusted_qc"])] <- " "
      bgc_data_yr["temp_adjusted_qc"][is.na(bgc_data_yr["temp_adjusted_qc"])] <- " "
      bgc_data_yr["psal_adjusted_qc"][is.na(bgc_data_yr["psal_adjusted_qc"])] <- " "
      bgc_data_yr["doxy_adjusted_qc"][is.na(bgc_data_yr["doxy_adjusted_qc"])] <- " "
      bgc_data_yr["nitrate_adjusted_qc"][is.na(bgc_data_yr["nitrate_adjusted_qc"])] <- " "
      bgc_data_yr["ph_in_situ_total_adjusted_qc"][is.na(bgc_data_yr["ph_in_situ_total_adjusted_qc"])] <- " "
      
      # Default qc counts for measurements - Pressure
      qc_deafaults <- data.frame(year=c(target_year, target_year, target_year, target_year, target_year, target_year, target_year, target_year),
                        measure=c("Pressure", "Pressure", "Pressure", "Pressure", "Pressure", "Pressure", "Pressure", "Pressure"),
                        measure_order=c(1, 1, 1, 1, 1, 1, 1, 1),
                        measure_qc=c('1', '2', '3', '4', '5', '8', '9', ' '),
                        count_measures=c(0, 0, 0, 0, 0, 0, 0, 0))
      bgc_measure_summary = rbind(bgc_measure_summary, qc_deafaults)
  
      # Build summary of qc flags for pressure and update bgc_measure_summary
      agg_tbl <- bgc_data_yr %>% group_by(year = target_year, measure = "Pressure", measure_order = 1, measure_qc = pres_adjusted_qc) %>% 
      summarise(count_measures=n())
      bgc_measure_summary <- rows_update(bgc_measure_summary, agg_tbl, by = c('year', 'measure_order', 'measure_qc'))
  
      # Default qc counts for measurements - temperature
      qc_deafaults <- data.frame(year=c(target_year, target_year, target_year, target_year, target_year, target_year, target_year, target_year),
                        measure=c("Temperature", "Temperature", "Temperature", "Temperature", "Temperature", "Temperature", "Temperature", "Temperature"),
                        measure_order=c(2, 2, 2, 2, 2, 2, 2, 2),
                        measure_qc=c('1', '2', '3', '4', '5', '8', '9', ' '),
                        count_measures=c(0, 0, 0, 0, 0, 0, 0, 0))
      bgc_measure_summary = rbind(bgc_measure_summary, qc_deafaults)
  
      # Build summary of qc flags for temperature and update bgc_measure_summary
      agg_tbl <- bgc_data_yr %>% group_by(year = target_year, measure = "Temperature", measure_order = 2, measure_qc = temp_adjusted_qc) %>% 
      summarise(count_measures=n())
      bgc_measure_summary <- rows_update(bgc_measure_summary, agg_tbl, by = c('year', 'measure_order', 'measure_qc'))
      
      # Default qc counts for measurements - salinity
      qc_deafaults <- data.frame(year=c(target_year, target_year, target_year, target_year, target_year, target_year, target_year, target_year),
                        measure=c("Salinity", "Salinity", "Salinity", "Salinity", "Salinity", "Salinity", "Salinity", "Salinity"),
                        measure_order=c(3, 3, 3, 3, 3, 3, 3, 3),
                        measure_qc=c('1', '2', '3', '4', '5', '8', '9', ' '),
                        count_measures=c(0, 0, 0, 0, 0, 0, 0, 0))
      bgc_measure_summary = rbind(bgc_measure_summary, qc_deafaults)
  
      # Build summary of qc flags for salinity and update bgc_measure_summary
      agg_tbl <- bgc_data_yr %>% group_by(year = target_year, measure = "Salinity", measure_order = 3, measure_qc = psal_adjusted_qc) %>% 
      summarise(count_measures=n())
      bgc_measure_summary <- rows_update(bgc_measure_summary, agg_tbl, by = c('year', 'measure_order', 'measure_qc'))

      # Default qc counts for measurements - pH
      qc_deafaults <- data.frame(year=c(target_year, target_year, target_year, target_year, target_year, target_year, target_year, target_year),
                        measure=c("pH", "pH", "pH", "pH", "pH", "pH", "pH", "pH"),
                        measure_order=c(4, 4, 4, 4, 4, 4, 4, 4),
                        measure_qc=c('1', '2', '3', '4', '5', '8', '9', ' '),
                        count_measures=c(0, 0, 0, 0, 0, 0, 0, 0))
      bgc_measure_summary = rbind(bgc_measure_summary, qc_deafaults)
  
      # Build summary of qc flags for pH and update bgc_measure_summary
      agg_tbl <- bgc_data_yr %>% group_by(year = target_year, measure = "pH", measure_order = 4, measure_qc = ph_in_situ_total_adjusted_qc) %>% 
      summarise(count_measures=n())
      bgc_measure_summary <- rows_update(bgc_measure_summary, agg_tbl, by = c('year', 'measure_order', 'measure_qc'))

      # Default qc counts for measurements - oxygen
      qc_deafaults <- data.frame(year=c(target_year, target_year, target_year, target_year, target_year, target_year, target_year, target_year),
                        measure=c("Oxygen", "Oxygen", "Oxygen", "Oxygen", "Oxygen", "Oxygen", "Oxygen", "Oxygen"),
                        measure_order=c(5, 5, 5, 5, 5, 5, 5, 5),
                        measure_qc=c('1', '2', '3', '4', '5', '8', '9', ' '),
                        count_measures=c(0, 0, 0, 0, 0, 0, 0, 0))
      bgc_measure_summary = rbind(bgc_measure_summary, qc_deafaults)
  
      # Build summary of qc flags for oxygen and update bgc_measure_summary
      agg_tbl <- bgc_data_yr %>% group_by(year = target_year, measure = "Oxygen", measure_order = 5, measure_qc = doxy_adjusted_qc) %>% 
      summarise(count_measures=n())
      bgc_measure_summary <- rows_update(bgc_measure_summary, agg_tbl, by = c('year', 'measure_order', 'measure_qc'))

      # Default qc counts for measurements - nitrate
      qc_deafaults <- data.frame(year=c(target_year, target_year, target_year, target_year, target_year, target_year, target_year, target_year),
                        measure=c("Nitrate", "Nitrate", "Nitrate", "Nitrate", "Nitrate", "Nitrate", "Nitrate", "Nitrate"),
                        measure_order=c(6, 6, 6, 6, 6, 6, 6, 6),
                        measure_qc=c('1', '2', '3', '4', '5', '8', '9', ' '),
                        count_measures=c(0, 0, 0, 0, 0, 0, 0, 0))
      bgc_measure_summary = rbind(bgc_measure_summary, qc_deafaults)
  
      # Build summary of qc flags for nitrate and update bgc_measure_summary
      agg_tbl <- bgc_data_yr %>% group_by(year = target_year, measure = "Nitrate", measure_order = 6, measure_qc = nitrate_adjusted_qc) %>% 
      summarise(count_measures=n())
      bgc_measure_summary <- rows_update(bgc_measure_summary, agg_tbl, by = c('year', 'measure_order', 'measure_qc'))

      rm(agg_tbl)
  
    } 
  
    # if updating metadata get the file based on bgc_index
    if (opt_refresh_years_metadata)
    {
      # read associated metadata
      bgc_metadata_yr <- argo_prof_prof(path = bgc_index)

      # see option section above for rational of why we want n_prof = 1 profiles
      bgc_metadata_yr <- bgc_metadata_yr %>%
      filter(n_prof == opt_n_prof_sel)
  
      bgc_metadata_yr <- bgc_metadata_yr %>%
        filter (!is.na(latitude) & !is.na(longitude))
    }
    
    # if temp or psal are being updated get the profile data
    if (opt_refresh_years_temp | opt_refresh_years_psal | opt_refresh_years_doxy | opt_refresh_years_nitrate | opt_refresh_years_pH)
    {
    
      # remove columns that are not needed in merged temperature and salinity files.
      # must have valid lat and lon
      bgc_index <- bgc_index %>%
        select(file,
               date,
               latitude,
               longitude) %>%
        filter (!is.na(latitude) & !is.na(longitude))
      
      # resolve lat and lon
      bgc_index <- bgc_index %>%
        rename(lon = longitude,
               lat = latitude) %>%
        mutate(lon = if_else(lon < 20, lon + 360, lon)) %>%
        mutate(
          lat = cut(lat, seq(-90, 90, 1), seq(-89.5, 89.5, 1)),
          lat = as.numeric(as.character(lat)),
          lon = cut(lon, seq(20, 380, 1), seq(20.5, 379.5, 1)),
          lon = as.numeric(as.character(lon))
        )
      
      # join to index to incorporate date, lat and lon
      bgc_data_yr <- left_join(bgc_data_yr, bgc_index)
      
      # derive depth using TEOS=10
      bgc_data_yr <- bgc_data_yr %>%
        filter (!is.na(lat) & !is.na(lon)) %>%
        mutate(depth = gsw_z_from_p(pres_adjusted, latitude =  lat) * -1.0,
               .before = pres_adjusted)

      bgc_data_yr <-
        bgc_data_yr %>%
        select(-c(n_levels, n_prof, pres_adjusted, pres_adjusted_error))

      # Remove any data records where depth is NA
      bgc_data_yr <- bgc_data_yr %>% filter(!is.na(depth))

    }
    

    # ------------------------------------------------------------------------------
    # Process temperature file
    # ------------------------------------------------------------------------------
    if (opt_refresh_years_temp)
    {    
      # Base temperature data where qc flag = good
      # Could this cause incomplete profiles to be maintained?
      bgc_data_temp_yr <- bgc_data_yr %>%
        filter(
          pres_adjusted_qc %in% c(1, 8) &
          temp_adjusted_qc %in% c(1, 8)
        ) %>%
        select(
          -contains(c("_qc", "psal", "doxy", "nitrate", "ph"))
        )
      
      # write this years file
      bgc_data_temp_yr %>%
        write_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_data_temp.rds"))
  
    }
    
    # ------------------------------------------------------------------------------
    # Process salinity file
    # ------------------------------------------------------------------------------
    if (opt_refresh_years_psal)
    {    
      # Base salinity data where qc flag = good
      bgc_data_psal_yr <- bgc_data_yr %>%
        filter(
          pres_adjusted_qc %in% c(1, 8) &
          psal_adjusted_qc %in% c(1, 8)
        ) %>%
        select(
          -contains(c("_qc", "temp", "doxy", "nitrate", "ph"))
        )
  
      # write this years file
      bgc_data_psal_yr %>%
        write_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_data_psal.rds"))
  
    }
  
    # ------------------------------------------------------------------------------
    # Process oxygen file
    # ------------------------------------------------------------------------------
    if (opt_refresh_years_doxy)
    {    
      # Base oxygen data where qc flag = good
      bgc_data_doxy_yr <- bgc_data_yr %>%
        filter(
          pres_adjusted_qc %in% c(1, 8) &
          doxy_adjusted_qc %in% c(1, 8)
        ) %>%
        select(
          -contains(c("_qc", "temp", "psal", "nitrate", "ph"))
        )
  
      # write this years file
      bgc_data_doxy_yr %>%
        write_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_data_doxy.rds"))
  
    }

    # ------------------------------------------------------------------------------
    # Process nitrate file
    # ------------------------------------------------------------------------------
    if (opt_refresh_years_nitrate)
    {    
      # Base nitrate data where qc flag = good
      bgc_data_nitrate_yr <- bgc_data_yr %>%
        filter(
          pres_adjusted_qc %in% c(1, 8) &
          nitrate_adjusted_qc %in% c(1, 8)
        ) %>%
        select(
          -contains(c("_qc", "temp", "psal", "doxy", "ph"))
        )
  
      # write this years file
      bgc_data_nitrate_yr %>%
        write_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_data_nitrate.rds"))
  
    }

    # ------------------------------------------------------------------------------
    # Process pH file
    # ------------------------------------------------------------------------------
    if (opt_refresh_years_pH)
    {    
      # Base nitrate data where qc flag = good
      bgc_data_pH_yr <- bgc_data_yr %>%
        filter(
          pres_adjusted_qc %in% c(1, 8) &
          ph_in_situ_total_adjusted_qc %in% c(1, 8)
        ) %>%
        select(
          -contains(c("_qc", "temp", "psal", "doxy", "nitrate"))
        )
  
      # write this years file
      bgc_data_pH_yr %>%
        write_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_data_pH.rds"))
  
    }
    
    # ------------------------------------------------------------------------------
    # Process metadata file
    # ------------------------------------------------------------------------------
    if (opt_refresh_years_metadata)
    {
      # resolve lat and lon so that it is hamonised with data files
      bgc_metadata_yr <- bgc_metadata_yr %>%
        rename(lon = longitude,
               lat = latitude) %>%
        mutate(lon = if_else(lon < 20, lon + 360, lon)) %>%
        mutate( 
          lat = cut(lat, seq(-90, 90, 1), seq(-89.5, 89.5, 1)),
          lat = as.numeric(as.character(lat)),
          lon = cut(lon, seq(20, 380, 1), seq(20.5, 379.5, 1)),
          lon = as.numeric(as.character(lon))
        )
    
      # Select just the columns we are interested in
      bgc_metadata_yr <- bgc_metadata_yr %>%
        select (
          file,
          date,
          lat,
          lon,
          platform_number, 
          cycle_number,
          position_qc,
          profile_pres_qc,
          profile_temp_qc,
          profile_psal_qc,
          profile_doxy_qc,
          profile_nitrate_qc,
          profile_ph_in_situ_total_qc
        )
  
      # write this years file
      bgc_metadata_yr %>%
        write_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_metadata.rds"))
  
    }
  
  }
  
  # write this years file
  bgc_measure_summary %>% 
    write_rds(file = paste0(path_argo_preprocessed, "/bgc_measure_summary.rds"))
  rm(bgc_measure_summary)
}
```

## Consolidate years

This process create six files in the path_argo_preprocessed directory that will be used for further analysis

### core_data_temp.rds

    file - the source file
    date - date of profile
    lat - aligned to closest 0.5Â° lat
    lon - aligned to closest 0.5Â° lon
    depth - calculated from pres_adjusted and latitude
    temp_adjusted - recorded and adjusted (after qc proccess) temperature
    temp_adjusted_error - recorded and adjusted (after qc proccess) temperature

### core_data_psal.rds

    file - the source file
    date - date of profile
    lat - aligned to closest 0.5Â° lat
    lon - aligned to closest 0.5Â° lon
    depth - calculated from pres_adjusted and latitude
    psal_adjusted - recorded and adjusted (after qc proccess) salinity
    psal_adjusted_error - recorded and adjusted (after qc proccess) salinity

### core_data_doxy.rds

    file - the source file
    date - date of profile
    lat - aligned to closest 0.5Â° lat
    lon - aligned to closest 0.5Â° lon
    depth - calculated from pres_adjusted and latitude
    doxy_adjusted - recorded and adjusted (after qc proccess) oxygen
    doxy_adjusted_error - recorded and adjusted (after qc proccess) oxygen

### core_data_nitrate.rds

    file - the source file
    date - date of profile
    lat - aligned to closest 0.5Â° lat
    lon - aligned to closest 0.5Â° lon
    depth - calculated from pres_adjusted and latitude
    nitrate_adjusted - recorded and adjusted (after qc proccess) nitrate
    nitrate_adjusted_error - recorded and adjusted (after qc proccess) nitrate

### core_data_pH.rds

    file - the source file
    date - date of profile
    lat - aligned to closest 0.5Â° lat
    lon - aligned to closest 0.5Â° lon
    depth - calculated from pres_adjusted and latitude
    ph_in_situ_total_adjusted - recorded and adjusted (after qc proccess) pH
    ph_in_situ_total_adjusted_error - recorded and adjusted (after qc proccess) pH

### core_metadata.rds

    file - the source file
    date - date of profile
    lat - aligned to closest 0.5Â° lat
    lon - aligned to closest 0.5Â° lon
    platform_number - identifier of float
    cycle_number - the profile number for the given float
    position_qc - qc flag associated with the positioning of the float profile
    profile_pres_qc - qc flag associated with the pressure readings of the profile (A-F)
    profile_temp_qc - qc flag associated with the temperature readings of the profile (A-F)
    profile_psal_qc - qc flag associated with the salinity readings of the profile (A-F)
    profile_doxy_qc - qc flag associated with the oxygen readings of the profile (A-F)
    profile_nitrate_qc - qc flag associated with the nitrate readings of the profile (A-F)
    profile_ph_in_situ_total_qc - qc flag associated with the pH readings of the profile (A-F)

```{r consolidate_into_allyears}
if (!opt_qc_only) {

  # ------------------------------------------------------------------------------
  # Process temperature file
  # ------------------------------------------------------------------------------
  if (opt_consolidate_temp){
    consolidated_created = 0
    
    for (target_year in opt_min_year:opt_max_year) {
  
      # read the yearly file based on target_year
      bgc_data_temp_yr <-
      read_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_data_temp.rds"))
  
      # Combine into a consolidated all years file
      if (consolidated_created == 0) {
        bgc_data_temp <- bgc_data_temp_yr
        consolidated_created = 1
      } else {
        bgc_data_temp <- rbind(bgc_data_temp, bgc_data_temp_yr)
      }
    }
    
    # write consolidated files  
    bgc_data_temp %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_data_temp.rds"))
  
    # remove files to free space
    rm(bgc_data_temp)
    rm(bgc_data_temp_yr)
    gc()
    
  }
  
  # ------------------------------------------------------------------------------
  # Process salinity file
  # ------------------------------------------------------------------------------
  if (opt_consolidate_psal){
    consolidated_created = 0
    
    for (target_year in opt_min_year:opt_max_year) {
  
      # read the yearly file based on target_year
      bgc_data_psal_yr <-
      read_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_data_psal.rds"))
  
      # Combine into a consolidated all years file
      if (consolidated_created == 0) {
        bgc_data_psal <- bgc_data_psal_yr
        consolidated_created = 1
      } else {
        bgc_data_psal <- rbind(bgc_data_psal, bgc_data_psal_yr)
      }
    }
    
    # write consolidated files  
    bgc_data_psal %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_data_psal.rds"))
  
    # remove files to free space
    rm(bgc_data_psal)
    rm(bgc_data_psal_yr)
    gc()
    
  }
  
  # ------------------------------------------------------------------------------
  # Process oxygen file
  # ------------------------------------------------------------------------------
  if (opt_consolidate_doxy){
    consolidated_created = 0
    
    for (target_year in opt_min_year:opt_max_year) {
  
      # read the yearly file based on target_year
      bgc_data_doxy_yr <-
      read_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_data_doxy.rds"))
  
      # Combine into a consolidated all years file
      if (consolidated_created == 0) {
        bgc_data_doxy <- bgc_data_doxy_yr
        consolidated_created = 1
      } else {
        bgc_data_doxy <- rbind(bgc_data_doxy, bgc_data_doxy_yr)
      }
    }
    
    # write consolidated files  
    bgc_data_doxy %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_data_doxy.rds"))
  
    # remove files to free space
    rm(bgc_data_doxy)
    rm(bgc_data_doxy_yr)
    gc()
    
  }
  
  # ------------------------------------------------------------------------------
  # Process nitrate file
  # ------------------------------------------------------------------------------
  if (opt_consolidate_nitrate){
    consolidated_created = 0
    
    for (target_year in opt_min_year:opt_max_year) {
  
      # read the yearly file based on target_year
      bgc_data_nitrate_yr <-
      read_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_data_nitrate.rds"))
  
      # Combine into a consolidated all years file
      if (consolidated_created == 0) {
        bgc_data_nitrate <- bgc_data_nitrate_yr
        consolidated_created = 1
      } else {
        bgc_data_nitrate <- rbind(bgc_data_nitrate, bgc_data_nitrate_yr)
      }
    }
    
    # write consolidated files  
    bgc_data_nitrate %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_data_nitrate.rds"))
  
    # remove files to free space
    rm(bgc_data_nitrate)
    rm(bgc_data_nitrate_yr)
    gc()
    
  }
  
  # ------------------------------------------------------------------------------
  # Process pH file
  # ------------------------------------------------------------------------------
  if (opt_consolidate_pH){
    consolidated_created = 0
    
    for (target_year in opt_min_year:opt_max_year) {
  
      # read the yearly file based on target_year
      bgc_data_pH_yr <-
      read_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_data_pH.rds"))
  
      # Combine into a consolidated all years file
      if (consolidated_created == 0) {
        bgc_data_pH <- bgc_data_pH_yr
        consolidated_created = 1
      } else {
        bgc_data_pH <- rbind(bgc_data_pH, bgc_data_pH_yr)
      }
    }
    
    # write consolidated files  
    bgc_data_pH %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_data_pH.rds"))
  
    # remove files to free space
    rm(bgc_data_pH)
    rm(bgc_data_pH_yr)
    gc()
    
  }
  
  # ------------------------------------------------------------------------------
  # Process metadata file
  # ------------------------------------------------------------------------------
  if (opt_consolidate_metadata){
    consolidated_created = 0
    
    for (target_year in opt_min_year:opt_max_year) {
  
      # read the yearly file based on target_year
      bgc_metadata_yr <-
      read_rds(file = paste0(path_argo_preprocessed, "/", target_year, "_bgc_metadata.rds"))
  
      # Combine into a consolidated all years file
      if (consolidated_created == 0) {
        bgc_metadata <- bgc_metadata_yr
        consolidated_created = 1
      } else {
        bgc_metadata <- rbind(bgc_metadata, bgc_metadata_yr)
      }
    }
    
    # write consolidated files  
    bgc_metadata %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_metadata.rds"))
  
    # remove files to free space
    rm(bgc_metadata)
    rm(bgc_metadata_yr)
    gc()
    
  }
}

```
















```{r load_indeces, include=FALSE}
# bgc_index <- argo_global_synthetic_prof() %>%
#   argo_filter_data_mode(data_mode = 'delayed') %>%  # load in delayed-mode data
#   argo_filter_date(date_min = '2013-01-01',
#                    date_max = Sys.time())  

# check the dates 
# max(bgc_subset$date, na.rm = TRUE)
# min(bgc_subset$date, na.rm = TRUE)

# checking alternative functions
# argo_global_meta(download = NULL, quiet = FALSE)

# argo_global_prof(download = NULL, quiet = FALSE)
# laods in core-argo files (CTD data)

# argo_global_tech(download = NULL, quiet = FALSE)
# An argo technical file contains technical information from an Argo float. This information is registered for each cycle performed by the float. 

# argo_global_traj(download = NULL, quiet = FALSE)
# argo_global_bio_traj(download = NULL, quiet = FALSE)
# load the trajectory files, which contain all received Argos and GPS locations of Argo floats. A trajectory file often contains core and BGC measurements performed at various intermediate times during the cycle and outside the vertical profiles. The full profiles collected upon ascent are not included and are stored in the profile files. 

# argo_global_bio_prof(download = NULL, quiet = FALSE)
# A B-Argo profile file contains all the parameters from a float, except the core-Argo parameters temperature, pressure, and salinity. A float that performs only CTD measurements does not have a B-Argo file

# argo_global_synthetic_prof(download = NULL, quiet = FALSE)

```

## Read data

Read in the adjusted bgc and core variables corresponding to the index files downloaded above, with their quality control flags. (can take a while)

```{r load_data_and_harmonize_variables, include=FALSE}

# bgc_data <- argo_prof_levels(
#   path = bgc_index,
#   vars =
#     c(
#       'PRES_ADJUSTED',
#       'PRES_ADJUSTED_QC',
#       'PRES_ADJUSTED_ERROR',
#       'PSAL_ADJUSTED',
#       'PSAL_ADJUSTED_QC',
#       'PSAL_ADJUSTED_ERROR',
#       'TEMP_ADJUSTED',
#       'TEMP_ADJUSTED_QC',
#       'TEMP_ADJUSTED_ERROR',
#       'DOXY_ADJUSTED',
#       'DOXY_ADJUSTED_QC',
#       'DOXY_ADJUSTED_ERROR',
#       'NITRATE_ADJUSTED',
#       'NITRATE_ADJUSTED_QC',
#       'NITRATE_ADJUSTED_ERROR',
#       'PH_IN_SITU_TOTAL_ADJUSTED',
#       'PH_IN_SITU_TOTAL_ADJUSTED_QC',
#       'PH_IN_SITU_TOTAL_ADJUSTED_ERROR'
#     ),
#   quiet = TRUE
# ) 
# # read in the profiles (takes a while)

  
```

## Read meta data

Read in the corresponding metadata:

```{r load_metadata, include=FALSE}

# bgc_metadata <- argo_prof_prof(path = bgc_index)

```

```{r load_calibration_information, include=FALSE}

# bgc_history = argo_prof_history(path = bgc_subset, quiet = TRUE)
# ?????
# returns blank output (0 observations of 0 variables)
# the same occurs if HISTORY_PARAMETER, HISTORY_ACTION, and HISTORY_QCTEST are added into the vars argument when loading the data 
# HISTORY_ACTION : Name of the action (either 'QCP$' for QC test performed, or 'QCF$' for QC test failed)
# HISTORY_PARAMETER : name of the parameter on which the action is performed 
# HISTORY_QCTEST : this field records the code of the QC test performed when ACTION is 'QCP$' or the QC test failed when ACTION is 'QCF$'

# bgc_calibration <- argo_prof_calib(path = bgc_subset, quiet = TRUE)
# contains the variables: 
# PARAMETER: name of the calibrated parameter(s) 
# SCIENTIFIC_CALIB_EQUATION : calibration equation applied to the parameter (if no adjustment is necessary or the data is not adjustable, this field records 'none')
# SCIENTIFIC_CALIB_COEFFICIENT : calibration coefficients for this equation (if no adjustment is necessary or the data is not adjustable, this field records 'none')
# SCIENTIFIC_CALIB_COMMENT : comment about this calibration
# if the delayed-mode adjusted value is the same as the raw value (CTD data) the comment records 'no adjustment necessary'; if the delayed-mode adjusted value has a QC flag of '4', the comment records 'bad data; not adjustable'. 
# SCIENTIFIC_CALIB_DATE : date when the calibration was performed

```

## Join data

Join the metadata and data together into one dataset

```{r create_dataset, include=FALSE}

# bgc_merge <- full_join(bgc_data, bgc_metadata)
# 
# bgc_merge <- bgc_merge %>%
#   select(
#     -c(profile_chla_qc:profile_cdom_qc),
#     -c(profile_cndc_qc:profile_up_radiance555_qc)
#   ) %>%
#   rename(lon = longitude,
#          lat = latitude) %>%
#   mutate(lon = if_else(lon < 20, lon + 360, lon)) %>%
#   mutate(
#     lat = cut(lat, seq(-90, 90, 1), seq(-89.5, 89.5, 1)),
#     lat = as.numeric(as.character(lat)),
#     lon = cut(lon, seq(20, 380, 1), seq(20.5, 379.5, 1)),
#     lon = as.numeric(as.character(lon))
#   ) %>%
#   mutate(depth = swDepth(pres_adjusted, latitude =  lat),
#          .before = pres_adjusted)


# bgc_merge_test <- full_join(bgc_data, bgc_calibration) (not sure why but it crashes R every time)

```

## Prepare for analysis


### pH data 

All pH data from BGC floats with QC flag 1 (good data)
ph_surface: pH data in the top 20 m of the watercolumn with QC flag 1  

### Temperature data 

All temperature data from BGC floats with QC flag 1 

### Temperature AB

BGC-temperature data with QC flags A and B, irrespective of whether a corresponding pH measurement exists

### pH & temperature AB

pH and temperature data from floats where both variables have full profiles with QC flag A or B

### pH & temperature data

pH and temperature data where both variables have QC flags 1 

### Write files 

write the files for later analysis

```{r create_pH_argo_dataframes}


if (!opt_qc_only) {

  if (opt_summary_files){
  
    # Read temp and meta_data
    bgc_data_temp <-
    read_rds(file = paste0(path_argo_preprocessed, "/bgc_data_temp.rds"))
    bgc_data_psal <-
    read_rds(file = paste0(path_argo_preprocessed, "/bgc_data_psal.rds"))

    bgc_data_doxy <-
    read_rds(file = paste0(path_argo_preprocessed, "/bgc_data_doxy.rds"))
    
    bgc_data_pH <-
    read_rds(file = paste0(path_argo_preprocessed, "/bgc_data_pH.rds"))
    bgc_metadata <-
    read_rds(file = paste0(path_argo_preprocessed, "/bgc_metadata.rds"))
    
    # ------------------------------------------------------------------------------
    # All pH data from BGC floats with QC flag 1 (good data)    
    # ------------------------------------------------------------------------------
    bgc_data_temp_join <- bgc_data_temp %>%
      select (
        file,
        depth, 
        temp_adjusted
      )
   
    bgc_data_psal_join <- bgc_data_psal %>%
      select (
        file,
        depth, 
        psal_adjusted
      )
    
    
  
    bgc_data_ph_temp_psal <- left_join(bgc_data_pH, bgc_data_temp_join)
    bgc_data_ph_temp_psal <- left_join(bgc_data_ph_temp_psal, bgc_data_psal_join)
     
    # Join pH, temp psal and meta_data to form merge
    bgc_merge_pH_qc_1 <- left_join(x = bgc_data_ph_temp_psal, 
                                       y = bgc_metadata %>% 
                                              select(file,
                                                  platform_number,
                                                  cycle_number,
                                                  profile_ph_in_situ_total_qc,
                                                  profile_temp_qc))

# bgc_merge_pH_qc_1 <- bgc_merge %>%
#   filter(ph_in_situ_total_adjusted_qc == '1') %>%
#   select(
#     date,
#     lat,
#     lon,
#     depth,
#     psal_adjusted,
#     temp_adjusted,
#     temp_adjusted_qc,
#     ph_in_situ_total_adjusted,
#     ph_in_situ_total_adjusted_qc,
#     platform_number,
#     cycle_number,
#     profile_ph_in_situ_total_qc,
#     profile_temp_qc
#   )

    # ------------------------------------------------------------------------------    
    # ph_surface: pH data in the top 20 m of the watercolumn with QC flag 1  
    # ------------------------------------------------------------------------------    

    # create a dataframe of full pH data (only good data) with corresponding CTD and metadata, 
    # in a 1x1Âº longitude/latitude grid
    ph_merge_1x1 <- bgc_merge_pH_qc_1 %>% 
                      mutate(
                        year = year(date),
                        month = month(date),
                        .before = depth
                        )
        
        
    # create a dataframe of pH data in the surface ocean (upper 20 m of the watercolumn),
    # in a 1x1Âº longitude/latitude grid
    ph_surface_1x1 <- ph_merge_1x1 %>%
      filter(between(depth, 0, 20))

    # create a dataframe of pH for the surface ocean (upper 20 m of the watercolumn),
    # in a 2x2Âº longitude/latitude grid
    ph_surface_2x2 <- ph_surface_1x1 %>%
      mutate(
        lat = cut(lat, seq(-90, 90, 2), seq(-89, 89, 2)),
        lat = as.numeric(as.character(lat)),
        lon = cut(lon, seq(20, 380, 2), seq(21, 379, 2)),
        lon = as.numeric(as.character(lon))
      )   # regrid into 2x2Âº grid

# # create a dataframe of full pH data (only good data) with corresponding CTD and metadata, in a 1x1Âº longitude/latitude grid
# ph_merge_1x1 <- bgc_merge %>%
#   select(
#     -c(doxy_adjusted:nitrate_adjusted_error),
#     -c(profile_doxy_qc, profile_nitrate_qc)
#   ) %>%
#   filter(ph_in_situ_total_adjusted_qc == '1') %>%
#   mutate(year = year(date),
#          month = month(date),
#          .after = n_prof)
# 
# 
# # create a dataframe of pH data in the surface ocean (upper 20 m of the watercolumn), in a 1x1Âº longitude/latitude grid
# ph_surface_1x1 <- ph_merge_1x1 %>%
#   filter(between(depth, 0, 20))
# 
# # create a dataframe of pH for the surface ocean (upper 20 m of the watercolumn) in a 2x2Âº longitude/latitude grid
# ph_surface_2x2 <- ph_surface_1x1 %>%
#   mutate(
#     lat = cut(lat, seq(-90, 90, 2), seq(-89, 89, 2)),
#     lat = as.numeric(as.character(lat)),
#     lon = cut(lon, seq(20, 380, 2), seq(21, 379, 2)),
#     lon = as.numeric(as.character(lon))
#   )   # regrid into 2x2Âº grid

    # ------------------------------------------------------------------------------            
    # All temperature data from BGC floats with QC flag 1     
    # ------------------------------------------------------------------------------        
    bgc_merge_temp_qc_1 <- left_join(x = bgc_data_temp, 
                                     y = bgc_metadata %>% 
                                          select(file,
                                              platform_number,
                                              cycle_number,
                                              profile_temp_qc))
    
# bgc_merge_temp_qc_1 <- bgc_merge %>% 
#   filter(temp_adjusted_qc == '1') %>% 
#   select(date, lat, lon, 
#          depth, temp_adjusted,
#          platform_number, cycle_number,
#          temp_adjusted_qc, ph_in_situ_total_adjusted_qc,
#          profile_temp_qc,
#          profile_ph_in_situ_total_qc)

    # ------------------------------------------------------------------------------            
    # BGC-temperature data with QC flags A and B, irrespective of whether a corresponding pH measurement exists
    # ------------------------------------------------------------------------------            
    bgc_merge_temp_AB <- bgc_merge_temp_qc_1 %>%
                          filter(profile_temp_qc == 'A' | profile_temp_qc == 'B')

    
# bgc_merge_temp_AB <- bgc_merge %>% 
#   filter(profile_temp_qc == 'A' | profile_temp_qc == 'B') %>% 
#   filter(temp_adjusted_qc == '1' | temp_adjusted_qc == '8') %>% 
#   select(date, lat, lon,
#          depth, temp_adjusted, temp_adjusted_qc,
#          platform_number, cycle_number,
#          profile_temp_qc)

    # ------------------------------------------------------------------------------                
    # pH and temperature data from floats where both variables have full profiles with QC flag A or B
    # ------------------------------------------------------------------------------                

    bgc_data_ph_temp <- left_join(bgc_data_pH, bgc_data_temp_join)

    # Join pH, temp psal and meta_data to form merge
    bgc_merge_qc_1 <- left_join(x = bgc_data_ph_temp, 
                                       y = bgc_metadata %>% 
                                              select(file,
                                                  platform_number,
                                                  cycle_number,
                                                  profile_ph_in_situ_total_qc,
                                                  profile_temp_qc))

    bgc_merge_flag_AB <- bgc_merge_qc_1 %>%
                          filter(profile_ph_in_situ_total_qc %in% c('A', 'B'),
                                 profile_temp_qc %in% c('A', 'B'))      
    
# # create a dataframe with temperature and pH profile flags A and B only 
# # keep only temperature observations where good pH data exists: 
# 
# # using only complete profiles, and temperature data where pH measurements exist:
# 
# bgc_merge_flag_AB <- bgc_merge %>%
#   filter(profile_ph_in_situ_total_qc %in% c('A', 'B'),
#          profile_temp_qc %in% c('A', 'B')) %>%
#   select(depth,
#          temp_adjusted:temp_adjusted_error,
#          ph_in_situ_total_adjusted:ph_in_situ_total_adjusted_error,
#          platform_number,
#          cycle_number,
#          date,
#          lat, lon,
#          profile_temp_qc,
#         profile_ph_in_situ_total_qc) %>%
#   filter(!is.na(ph_in_situ_total_adjusted))
# # no NA temperature values
# # 518 340 total observations 
    
    # ------------------------------------------------------------------------------                
    # pH and temperature data where both variables have QC flags 1 
    # ------------------------------------------------------------------------------                
    # bgc_merge_qc_1 created in step above.

    
    # ------------------------------------------------------------------------------                
    # doxy data where both variables have QC flags 1 
    # ------------------------------------------------------------------------------                
    # Join doxy and meta_data to form merge
    bgc_merge_doxy_qc_1 <- left_join(x = bgc_data_doxy, 
                                       y = bgc_metadata %>% 
                                              select(file,
                                                  platform_number,
                                                  cycle_number,
                                                  profile_ph_in_situ_total_qc,
                                                  profile_temp_qc))

            
# bgc_merge_qc_1 <- bgc_merge %>% 
#   filter(ph_in_situ_total_adjusted_qc == '1',
#          temp_adjusted_qc == '1') %>% 
#   select(depth,
#          temp_adjusted:temp_adjusted_error,
#          ph_in_situ_total_adjusted:ph_in_situ_total_adjusted_error,
#          platform_number,
#          cycle_number,
#          date,
#          lat, lon,
#          profile_temp_qc,
#          profile_ph_in_situ_total_qc)
    

    # bgc_index %>%
    #   write_rds(file = paste0(path_argo_preprocessed, "/bgc_index.rds"))
    # 
    # # bgc_calibration %>%
    # #  write_rds(file = paste0(path_argo_preprocessed, "/bgc_calibration.rds"))
    # 
    # bgc_data %>%
    #   write_rds(file = paste0(path_argo_preprocessed, "/bgc_data.rds"))
    # 
    # bgc_merge %>%
    #   write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge.rds"))
    
    
    bgc_merge_pH_qc_1 %>%
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_pH_qc_1.rds"))
    
    bgc_merge_temp_qc_1 %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_temp_qc_1.rds"))
    
    bgc_merge_temp_AB %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_temp_AB.rds"))
    
    bgc_merge_flag_AB %>%
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_flag_AB.rds"))
    
    bgc_merge_qc_1 %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_qc_1.rds"))
    
    ph_merge_1x1 %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/ph_merge_1x1.rds"))
    
    ph_surface_1x1 %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/ph_surface_1x1.rds"))
    
    ph_surface_2x2 %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/ph_surface_2x2.rds"))
        
    bgc_merge_doxy_qc_1 %>% 
      write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_doxy_qc_1.rds"))


  }
}




```

## QC summary

### profile QC flags (A-F)

Produce a summary of profile QC flags (A-F)

```{r set_global_theme, include=FALSE}

theme_set(theme_bw())
```


```{r QC_summary_profile, fig.asp=0.6}

# Read metadata file and create profile summary table with a count for each year, measurement type and qc option
bgc_metadata <-
read_rds(file = paste0(path_argo_preprocessed, "/bgc_metadata.rds"))
bgc_metadata["profile_pres_qc"][is.na(bgc_metadata["profile_pres_qc"])] <- "" 
bgc_metadata["profile_temp_qc"][is.na(bgc_metadata["profile_temp_qc"])] <- "" 
bgc_metadata["profile_psal_qc"][is.na(bgc_metadata["profile_psal_qc"])] <- "" 
bgc_metadata["profile_doxy_qc"][is.na(bgc_metadata["profile_doxy_qc"])] <- "" 
bgc_metadata["profile_nitrate_qc"][is.na(bgc_metadata["profile_nitrate_qc"])] <- "" 
bgc_metadata["profile_ph_in_situ_total_qc"][is.na(bgc_metadata["profile_ph_in_situ_total_qc"])] <- "" 

bgc_profile_summary <- bgc_metadata %>% 
  filter (profile_temp_qc != "") %>%
  group_by(
    year = format(date, "%Y"), 
    measure = "Temperature", 
    measure_order = 2, 
    profile_qc = profile_temp_qc
    ) %>% 
  summarise(
    count_profiles = n()
    )
bgc_profile_summary <- rbind(bgc_profile_summary, 
                              bgc_metadata %>% 
                                filter (profile_ph_in_situ_total_qc != "") %>%
                                group_by(
                                  year = format(date, "%Y"), 
                                  measure = "pH", 
                                  measure_order = 4, 
                                  profile_qc = profile_ph_in_situ_total_qc
                                  ) %>% 
                                summarise(
                                  count_profiles = n()
                                  ))
bgc_profile_summary <- rbind(bgc_profile_summary, 
                              bgc_metadata %>% 
                                filter (profile_doxy_qc != "") %>%
                                group_by(
                                  year = format(date, "%Y"), 
                                  measure = "oxygen", 
                                  measure_order = 5, 
                                  profile_qc = profile_doxy_qc
                                  ) %>% 
                                summarise(
                                  count_profiles = n()
                                  ))
# modify data frame to prepare for plotting
bgc_profile_summary <- ungroup(bgc_profile_summary)
bgc_profile_summary <- bgc_profile_summary %>% group_by(measure_order)
bgc_profile_summary <- transform(bgc_profile_summary, year = as.numeric(year))

year_min <- min(bgc_profile_summary$year)
year_max <- max(bgc_profile_summary$year)
facet_label <- as_labeller(c("2"="Temperature", "4"="pH", "5"="Oxygen"))
  
# draw plots for the separate parameters
bgc_profile_summary %>%
  ggplot(aes(x = year, y = count_profiles, col = profile_qc, group=profile_qc)) +
          geom_point() +
          geom_line() +
          facet_wrap(~measure_order, labeller = facet_label) +
          scale_x_continuous(breaks = seq(year_min, year_max, 2)) +
          labs(x = 'year', 
               y = 'number of profiles', 
               col = 'profile QC flag',
               title = 'Count of profile qc flags by year')
  

```

### measurement QC flags (1-9)

Produce a summary of current measurement QC flags (1-9)

```{r QC_summary_measure, fig.asp=0.6}

# Read temp and meta_data
bgc_measure_summary <-
read_rds(file = paste0(path_argo_preprocessed, "/bgc_measure_summary.rds"))
bgc_measure_summary <- ungroup(bgc_measure_summary)

year_min <- min(bgc_measure_summary$year)
year_max <- max(bgc_measure_summary$year)

# draw plots for the separate parameters
bgc_measure_summary %>%
  filter(measure_qc != " " & measure_order %in% c(2, 4, 5)) %>%
  ggplot(aes(x = year, y = count_measures, col = measure_qc, group=measure_qc)) +
          geom_point() +
          geom_line() +
          facet_wrap(~measure_order, labeller = facet_label) +
          scale_x_continuous(breaks = seq(year_min, year_max, 2)) +
          labs(x = 'year', 
               y = 'number of measures', 
               col = 'measure QC flag',
               title = 'Count of measure qc flags by year')

```












## Harmonise metadata 

```{r harmonise_metadata_variables, include=FALSE}

# bgc_metadata <- bgc_metadata %>%
#   rename(lon = longitude,
#          lat = latitude) %>%
#   mutate(lon = if_else(lon < 20, lon + 360, lon)) %>%
#   mutate(
#     lat = cut(lat, seq(-90, 90, 1), seq(-89.5, 89.5, 1)),
#     lat = as.numeric(as.character(lat)),
#     lon = cut(lon, seq(20, 380, 1), seq(20.5, 379.5, 1)),
#     lon = as.numeric(as.character(lon))
#   ) %>% 
#   select(
#     -c(profile_chla_qc:profile_cdom_qc),
#     -c(profile_cndc_qc:profile_up_radiance555_qc)
#   )

```

## Write Argo data to files 

```{r write_argo_data_files, include=FALSE}

# bgc_index %>%
#   write_rds(file = paste0(path_argo_preprocessed, "/bgc_index.rds"))
# 
# # bgc_calibration %>%
# #  write_rds(file = paste0(path_argo_preprocessed, "/bgc_calibration.rds"))
# 
# bgc_data %>%
#   write_rds(file = paste0(path_argo_preprocessed, "/bgc_data.rds"))
# 
# bgc_merge %>%
#   write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge.rds"))
# 
# 
# bgc_merge_pH_qc_1 %>%
#   write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_pH_qc_1.rds"))
# 
# 
# bgc_merge_temp_qc_1 %>% 
#   write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_temp_qc_1.rds"))
# 
# bgc_merge_temp_AB %>% 
#   write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_temp_AB.rds"))
# 
# 
# bgc_merge_flag_AB %>%
#   write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_flag_AB.rds"))
# 
# # bgc_merge_flag_A_test %>%
# #   write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_flag_A_test.rds"))
# 
# bgc_merge_qc_1 %>% 
#   write_rds(file = paste0(path_argo_preprocessed, "/bgc_merge_qc_1.rds"))
# 
# ph_merge_1x1 %>% 
#   write_rds(file = paste0(path_argo_preprocessed, "/ph_merge_1x1.rds"))
# 
# bgc_metadata %>%
#   write_rds(file = paste0(path_argo_preprocessed, "/bgc_metadata.rds"))
# 
# ph_surface_1x1 %>% 
#   write_rds(file = paste0(path_argo_preprocessed, "/ph_surface_1x1.rds"))
# 
# ph_surface_2x2 %>% 
#   write_rds(file = paste0(path_argo_preprocessed, "/ph_surface_2x2.rds"))

```

# Data set description

## Argo Columns

The resulting bgc_merge dataframe contains:

-   the file name (`file` column)

-   the sampling level (`n_level` column)

-   the number of profiles per file (`n_prof` column; Each single-cycle synthetic profile has the dimension `n_prof = 1`).

-   adjusted values for pressure (`pres`, in dbar), salinity (`psal`, in psu), temperature (`temp`, in degrees C), dissolved oxygen (`doxy`, in Âµmol kg^-1^), pH (`ph_in_situ_total`), and nitrate (`nitrate`, in Âµmol kg^-1^) (`parameter_adjusted` columns). This column is mandatory, so if no adjustment was performed (i.e. `parameter_adjusted` does not exist), FillValue is inserted (e.g., `temp_adjusted:FillValue = 99999.f`). If the raw value did not require adjustment in delayed-mode, then `parameter_adjusted` = `parameter`.

-   a quality control flag associated with these adjusted values (`parameter_adjusted_qc` columns). If an adjusted value does not exist (e.g., `temp_adjusted = 99999.f`), then FillValue is inserted (e.g., `temp_adjusted_qc = " "`).

-   an error estimate on the adjustment of the measurement (`parameter_adjusted_error` columns). If no adjusted value exists (e.g., `temp_adjusted = 99999.f`), then FillValue is inserted (e.g., `temp_adjusted_error = 99999.f`)

-   WMO float identifier (`platform_number` column)

-   name of the project in charge of the float (`project_name` column)

-   name of principal investigator in charge of the float (`pi_name` column)

-   float cycle number (`cycle_number` column; *cycle 0 is the launch cycle during which technical data or configuration information is transmitted; cycle 1 is the first complete cycle*)

-   descending (D) or ascending (A) profile (`direction` column). *Profile measurements are taken on ascent, occasionally during descent (rarely both).*

-   code for the data centre in charge of the float data management (`data_centre` column)

-   the type of float (`platform_type` column)

-   firmware version of the float (`firmware_version` column)

-   instrument type from the WMO code table 1770 (`wmo_inst_type` column)

-   the date and time at which the measurement was taken, in UTC (`date` column)

-   a quality control flag for the date and time value (`date_qc` column)

-   the date and time of the profile location (`date_location` column)

-   latitude in degrees N (`latitude` column)

-   longitude in degrees E (`longitude` column)

-   quality control flag on the position (`position_qc` column)

-   name of the system in charge of positioning the float locations (`positioning_system` column)

-   unique number of the mission to which this float belongs (`config_mission_number` column,

-   a global quality control flag on the profile of the parameter (`profile_parameter_qc` column; FillValue = " ")

## QC flags

QC flags for values ('`parameter_adjusted_qc`' columns) are between 1 and 8, where:\
1 is 'good' data,\
2 is 'probably good' data,\
3 is 'probably bad' data,\
4 is 'bad' data,\
5 is 'value changed',\
8 is 'estimated value',\
9 is 'missing value' (data parameter will record FillValue)\
(6 and 7 are not used).

Profile QC flags ('`profile_parameter_qc`' columns) are QC codes attributed to the entire profile, and indicate the number of depth levels (in %) where the value is considered to be good data (QC flags of 1, 2, 5, and 8; QC flags of 9 or " " are not used in the computation):\
'A' means 100% of profile levels contain good data,\
'B' means 75-\<100% of profile levels contain good data,\
'C' means 50-75% of profile levels contain good data,\
'D' means 25-50% of profile levels contain good data,\
'E' means \>0-25% of profile levels contain good data,\
'F' means 0% of profile levels contain good data.

### Quality Control Tests

There are two levels of Argo data quality control:

-   The first level is the real-time system that performs a set of agreed automatic checks
-   The second level is the delayed-mode quality control system.

#### Real-time QC tests

1.  **Platform identification test**

If a float WMO ID cannot be matched to the correct float platform then none of the data will be distributed.

2.  **Impossible date test**

This test requires that the Julian Day of the float be later than 1st January 1997 and earlier than the current date of the check (in UTC time). If the date of a profile fails this test, the date of the profile should be flagged as bad data ('4') and none of the profile data is distributed.

3.  **Impossible location test**

This test requires that the observation latitude and longitude of a float be sensible, with latitude in the range -90 to 90Âº, and longitude in the range -180 to 180Âº.

If either latitude or longitude fails this test, the position is flagged as bad data ('4') and none of the profile data is distributed.

4.  **Position on land test**

This test requires that the observation latitude and longitude be located in an ocean. If a position cannot be located in an ocean, the position is flagged as bad data ('4') and none of the profile data is distributed.

5.  **Impossible speed test**

Drift speeds for floats can be generated given the positions and times of the floats when they are at the sea surface and between profiles. In all cases, we would not expect the drift speed to exceed 3 ms^-1^. If it does, it means either the positions or times are bad data, or a float is mislabeled. Using the multiple positions and times that are normally available for a float while at the sea surface, it is often possible to isolate the one position or time that is an error.

If an acceptable position and time can be used from the available suite, then the data can be distributed. Otherwise, the position, the time, or both, are flagged as bad data ('4') and the profile data is not distributed.

6.  **Global range test**

This test applies a gross filter on the values of `TEMP`, `PRES`, and `PSAL`. The ranges need to accommodate all of the expected extremes in the ocean.

-   Pressure cannot be less than -5 dbar. If `PRES` \< -5, then `PRES_QC` = '4', `TEMP_QC` = '4', and `PSAL_QC` = '4'.
-   Pressure in the range -5 to -2.4 dbar should be considered 'probably bad' data. If -5 â¤ `PRES` â¤ -2.4, then `PRES_QC` = '3', `TEMP_QC` = '3', `PSAL_QC` = '3'.
-   Temperature should be in the range -2.5 to 40.0 ÂºC. Outside of this range `TEMP_QC` = '4'.
-   Salinity should be in the range 2 to 41.0 PSU. Outside of this range, `PSAL_QC` = '4'.
-   `DOXY` should be in the range -5 to 600 Âµmol kg^-1^. Outside of this range, `DOXY_QC = '4'`.
-   `PH_IN_SITU_TOTAL` should be in the range 7.3 to 8.5. Outside of this range, `PH_IN_SITU_TOTAL_QC = '4'`.

7.  **Regional range test** (CTD data)

This test applies to certain regions of the world where conditions can be further qualified. In this case, specific ranges for observations from the Mediterranean Sea and the Red Sea further restrict what can be accepted as reasonable values.

If a value fails this test, it is flagged as bad data ('4') and removed from the initial distribution. If temperature and salinity at the same pressure level both fail this test, both values are flagged as bad data ('4') and values for pressure, temperature, and salinity are removed from the distribution.

8.  **Pressure increasing test** (CTD data)

This test requires that the vertical profile has pressures that are monotonically increasing (assuming the pressure levels are ordered from smallest to largest).

If there is a region of constant pressure, all but the first of the consecutive constant pressure levels is flagged as bad data ('4'). If there is a region where pressure reverses, all of the pressures in the reversed part of the profile are flagged as bad data ('4'). All pressures flagged as bad data and associated temperatures and salinities are removed.

9.  **Spike test**

The difference between sequential measurements, where one measurement is significantly different from adjacent ones, is a spike in both size and gradient. This test does not consider differences in pressure, but assumes a sampling that adequately reproduces changes in temperature and salinity with pressure.

Test value = \| V2 - (V3 + V1)/2 \| - \| (V3 - V1)/2 \|

where V2 is the measurement being tested, and V1 and V3 are the values above and below.

Temperature: the V2 value is flagged when:

-   the test value exceeds 6.0 ÂºC for pressures less than 500 dbar, or
-   the test value exceeds 2.0 ÂºC for pressures equal to or greater than 500 dbar.

Salinity: the V2 value is flagged when:

-   the test value exceeds 0.9 PSU for pressures less than 500 dbar, or
-   the test value exceeds 0.3 PSU for pressures equal to or greater than 500 dbar.

DOXY: the V2 value is flagged when:

-   the test value exceeds 50 Âµmol kg^-1^ for pressures less than 500 dbar, or
-   the test value exceeds 25 Âµmol kg^-1^ for pressures equal to or greater than 500 dbar.

For pH:

Test value 2 = \| V2 - median(V0, V1, V2, V3, V4) \|

where the test value represents the anomaly of the observed pH from the median of the surrounding data. A pH data point is considered a spike and flagged as bad ('4') if Test Value 2 \> 0.04pH

If the value V2 fails this test, it is flagged as bad data ('4') and is removed. If temperature and salinity both fail this test, both values are flagged as bad data ('4') and values for temperature, salinity and pressure are removed.

10. Obsolete
11. **Gradient test** (DOXY only)

This test is failed when the difference between vertically adjacent measurements is too steep. The test does not consider changes in depth, but assumes a sampling that adequately reproduces changes in DOXY with depth

Test value = \| V2 - (V3 + V1)/2 \|

where V2 is the value being tested as a spike, and V1 and V3 are the values above and below.

For DOXY, V2 is flagged when:

-   the test value exceeds 50 Âµmol kg^-1^ for pressures less than 500 dbar, or

-   the test value exceeds 25 Âµmol kg^-1^ for pressures equal to or greater than 500 dbar

12. **Digit rollover test** (CTD data)

Only so many bits are allowed to store temperature and salinity values in a profiling float. This range is not always large enough to accommodate conditions which are encountered in the ocean. When the range is exceeded, stored values rollover to the lower end of the range. This rollover should be detected and compensated for when profiles are constructed from the data stream of the float. This test is used to make sure the rollover is properly detected.

-   Temperature difference between adjacent pressures > 10 ÂºC
-   Salinity difference between adjacent pressures > 5 PSU

If a value fails this test, it is flagged as bad data ('4') and removed from the initial distribution. If temperature and salinity at the same pressure level both fail this test, both values are flagged as bad data ('4') and values for pressure, temperature, and salinity are removed from the distribution.

13. **Stuck value test**

This test looks for CTD and BGC measurements in the same profile being identical.

If this occurs, all of the values affected parameter are flagged as bad data ('4') and removed from the distribution. If both temperature and salinity are affected, then all observed values from the profile are flagged as bad data ('4').

14. **Density inversion test** (CTD data)

This test compares potential density between valid measurements in a profile in both directions (i.e., from top to bottom, and from bottom to top). Values of temperature and salinity at the same pressure level P~i~ are used to compute potential density Ï~i~ ( or Ï~i~ = Ï~i~ - 1000) kg m^-3^, referenced to the mid-point between Pi and the next valid pressure level. A threshold of 0.03 kg m^-3^ is allowed for small density inversions.

From top to bottom, if the potential density calculated at the greater pressure P~i+1~ is less than that calculated at the lesser pressure P~i~ by more than 0.03 kg m~-3~, both the temperature and salinity values at pressure P~i~ are flagged as bad data ('4'). From bottom to top, if the potential density calculated at the lesser pressure P~i-1~ is greater than that calculated at the greater pressure P~i~ by more than 0.03 kg m~-3~, both the temperature and salinity values at pressure P~i~ are flagged as bad data ('4'). Bad temperature and salinity are removed from the distribution.

15. **Grey list test**

This test is implemented as a mechanism for data assembly centers (DACs) to flag, in real-time, sensors that are potentially not working correctly. Each DAC manages a grey list and sends it to the GDACs. The merged grey list from all DACs is available from the GDACs.

Naming convention: `xxx_greylist.csv` (where `xxx` is the DAC name, e.g., `aoml_greylist.csv`, `coriolis_greylist.csv`, etc).

Columns: `PLATFORM`, `PARAMETER`, `START_DATE`, `END_DATE`, `QC`, `COMMENT`, `DAC`

The decision to insert a float parameter in the grey list comes from the PI or the delayed-mode operator. A float parameter should be put in the grey list when the sensor drift is too big to be adjusted in real-time, or when the sensor is judged to be potentially not working correctly.

The grey list concerns only real-time files. When an anomalous float is dead and the offending parameter has been adjusted in delayed-mode, it is removed from the grey list. When an anomalous float is active and the offending parameter has been partially adjusted in delayed-mode, it will remain on the grey list if real-time adjustment is not adequate.

Grey-listed parameters are flagged as probably good ('2'), probably bad ('3') or bad ('4') data, as determined by the PI or the delayed-mode operator.

16. **Gross salinity or temperature sensor drift test** (CTD)

This test is implemented to detect a sudden and significant sensor drift. It calculates the average temperature and salinity from the deepest 100 dbar of a profile and the previous good profile. Only measurements with good QC are used.

For salinity, if the difference between the two average values is more than 0.5 PSU, then all the salinity values of the profile are flagged as probably bad data ('3'). For temperature, if the difference between the two average values is more than 1 ÂºC, then all the temperature values from the profile are flagged as probably bad data ('3').

17. **Visual QC test**

This is subjective visual inspection of float measurements by an operator. This test is not mandatory before real-time data distribution.

18. **Frozen profile test** (CTD data)

This test is used to detect a float that produces the same profile (with very small deviations) over and over again. Typically the differences between two profiles are of the order of 0.001 PSU for salinity and of the order 0.01 ÂºC for temperature.

A)  Derive temperature and salinity profiles by averaging the original profiles to get mean values for each profile in 50 dbar slabs (T_prof, T_previous_prof, S_prof, S_previous_prof). This is necessary because the floats do not sample at the same level in each profile.

B)  Obtain absolute values of the difference between the averaged temperature and salinity profiles as follows:

-   deltaT = abs(T_prof - T_previous_prof)
-   deltaS = abs(S_prof - S_previous_prof)

C)  Find the maximum, minimum, and mean of the absolute values of the averaged differences between profiles for temperature and salinity:

-   mean(deltaT), max(deltaT), min(deltaT)
-   mean(deltaS), max(deltaS), min(deltaS)

D)  To fail the test, require that:

-   max(deltaT) \< 0.3 ÂºC
-   min(deltaT) \< 0.001 ÂºC
-   mean(deltaT) \< 0.02 ÂºC
-   max(deltaS) \< 0.3 PSU
-   min(deltaS) \< 0.001 PSU
-   mean(deltaS) \< 0.004 PSU

If a profile fails this test, all measurements from this profile are flagged as bad data ('4'). If a float fails this test over 5 consecutive cycles, it is inserted in the grey list.

19. **Deepest pressure test**

This test requires that a profile has pressures that are not greater than `CONFIG_ProfilePressure_dbar` plus 10%. The value of `CONFIG_ProfilePressure_dbar` is in the meta.nc file of the float.

If there is a region of incorrect pressures, those pressures and their corresponding temperature and salinity measurements are flagged as bad data ('4'). Pressures flagged as bad data and their associated measurements should be removed from distribution.

25. **MEDian with a distance (MEDD) test** (CTD)

This test is a set of algorithms based on three main steps:

-   First, the computation of a sliding median with some customizations
-   Then, limits are computed that are at relative 2-dimension distance d from the median
-   Finally, these limits are also computed for the density profile. There is a spike if both the density profile measurement profile are out of limits. If there is no conductivity sensor, then the spikes in temperature are evaluated using a bigger d value.

Temperature and salinity values that fail this test are flagged as bad data ('4').

56. **pH-specific real-time QC test** (PH_IN_SITU_TOTAL only)

Currently, there is no pH-specific QC test. If one is established, it will be reported with the number '56'.

Real-time pH values which pass the real-time QC tests are assigned QC flags of '3'. The Argo goals for research-quality data require that pH values be adjusted to receive a quality flag of '1'.

57. **DOXY-specific real-time QC test** (DOXY only)

Real-time unadjusted `DOXY`values receive QC flags of '3'. This is because the majority of oxygen sensors deployed on BGC Argo profiling floats are Aanderaa optodes that suffer from pre-deployment storage drift that can reduce accuracy by up to 20% or more. Because this is a known bias that affects the majority of oxygen sensors within the array, and because it can be corrected, `DOXY_QC` is set to '3'.

59. **Nitrate-specific real-time QC test** (NITRATE only)

*Not yet available*

#### Test application order on vertical profiles

The Argo real-time QC tests on CTD data (temperature, salinity, pressure) are performed in the order described in the following table.

A CTD measurement with a QC flag '4' is ignored by other QC tests. A measurement with QC flag '2' or '3' is tested by other QC tests.

A `DOXY` measurement with a QC flag '4' or '3' is ignored by other QC tests.

Note that the Test Number is different from the Application Order. The Test Number (n) is a number assigned permanently to each QC test. It is used to fill `HISTORY_QCTEST` in the Argo profile files. Therefore, each Test Number is uniquely associated to a QC test, and is never replaced, changed, or duplicated.

Each real-time QC test has a unique Binary ID (2^n^) of the unique Test Number (n) is used to record QC tests performed and failed in the variable `HISTORY_QCTEST`.

The QC flag assigned by a test cannot override a higher value assigned by a previous QC test.

e.g.: a QC flag '4' (bad data) set by the Grey List Test cannot be decreased to QC flag '3' (bad data that are potentially correctable) set by the Gross Salinity or Temperature Sensor Drift Test.

| Application Order for CTD parameters | Test Number (n) | Binary ID (2^n^) | Test Name                                       |
|--------------------------------------|-----------------|------------------|-------------------------------------------------|
| 1                                    | 1               | 2                | Platform Identification Test                    |
| 2                                    | 2               | 4                | Impossible Date Test                            |
| 3                                    | 3               | 8                | Impossible Location Test                        |
| 4                                    | 4               | 16               | Position on Land Test                           |
| 5                                    | 5               | 32               | Impossible Speed Test                           |
| 6                                    | 15              | 32768            | Grey List Test                                  |
| 7                                    | 19              | 524288           | Deepest Pressure Test                           |
| 8                                    | 6               | 64               | Global Range Test                               |
| 9                                    | 7               | 128              | Regional Range Test                             |
| 10                                   | 8               | 256              | Pressure Increasing Test                        |
| 11                                   | 9               | 512              | Spike Test                                      |
| 12                                   | 25              | 33554432         | MEDD Test                                       |
| 13                                   | 12              | 4096             | Digit Rollover Test                             |
| 14                                   | 13              | 8192             | Stuck Value Test                                |
| 15                                   | 14              | 16384            | Density Inversion Test                          |
| 16                                   | 16              | 65536            | Gross Salinity or Temperature Sensor Drift Test |
| 17                                   | 18              | 261144           | Frozen Profile Test                             |
| *18*                                 | *17*            | 131072           | *Visual QC Test*                                |

The real-time tests for BGC parameters are performed in the order described in the following table:

| Application order for BGC parameters | Test Number (n) | Binary ID (2^n^) | Test Name                                                  |
|--------------------------------------|-----------------|------------------|------------------------------------------------------------|
| 1                                    | 19              | 524288           | Deepest Pressure Test                                      |
| 2                                    | 1               | 2                | Platform Identification Test                               |
| 3                                    | 2               | 4                | Impossible Date Test                                       |
| 4                                    | 3               | 8                | Impossible Location Test                                   |
| 5                                    | 4               | 16               | Position on Land Test                                      |
| 6                                    | 5               | 32               | Impossible Speed Test                                      |
| 7                                    | 6               | 64               | Global Range Test                                          |
| 8                                    | 7               | 128              | Regional Range Test                                        |
| 9                                    | 9               | 512              | Spike Test                                                 |
| 10                                   | 11              | 2048             | Gradient Test                                              |
| 11                                   | 12              | 4096             | Digit Rollover Test                                        |
| 12                                   | 13              | 8192             | Stuck Value Test                                           |
| 13                                   | 15              | 32768            | Grey List Test                                             |
| *14*                                 | *16*            | *65536*          | *Gross Temperature Sensor Drift Test (only for TEMP_DOXY)* |
| 15                                   | 18              | 261144           | Frozen Profile Test                                        |
| 16                                   |                 |                  | BGC parameter-specific tests                               |
| *17*                                 | *17*            | *131072*         | *Visual QC Test*                                           |

#### Delayed-Mode Quality Control

The QC flags determined in delayed-mode replace those assigned in real-time because some bad data cannot be detected by the real-time tests, and some good data can be identified wrongly as bad by the real-time tests.

For vertical profile data, delayed-mode operators examine them for pointwise errors (such as spikes and jumps) and flag them appropriately. If an error is identified, both `PARAM_QC` and `PARAM_ADJUSTED_QC` record '4'. Conversely, if good data have wrongly been identified as bad by the real-time tests, then `PARAM_QC` and `PARAM_ADJUSTED_QC` record '1'.

In SD-files, the variables `PROFILE_PARAMETER_QC`, `PARAMETER_ADJUSTED`, `PARAMETER_ADJUSTED_QC`, and `PARAMETER_ADJUSTED_ERROR` are compulsory. If no adjustment in delayed-mode is necessary and if the flag is deemed assigned correctly, then `PARAM_ADJUSTED = PARAMETER`, `PARAM_ADJUSTED_QC = PARAM_QC`, and `PARAM_ADJUSTED_ERROR` is provided by the PI.

If no delayed-mode adjustment was performed, then `PARAM_ADJUSTED = 99999.f`, `PARAM_ADJUSTED_QC = " "`, `PARAM_ADJUSTED_ERROR = 99999.f` and `PROFILE_PARAMETER_QC = " "`.

If values are deemed unadjustable in delayed-mode, then `PARAM_ADJUSTED_QC = '4'`, and `PARAM_ADJUSTED = 99999.f` and `PARAM_ADJUSTED_ERROR = 99999.f`.

The variable `PROFILE_PARAMETER_QC` is recomputed when `PARAMETER_ADJUSTED_QC` becomes available.

**Dates**

Delayed-mode operators check that the dates in the profile are in chronological order. Erroneous or missing dates are replaced with another telemetered value if available, or replaced with interpolated values and marked `DATE_QC = '8'`.

**Location**

Profile positions `LONGITUDE`, `LATITUDE` are checked for outliers. Erroneous or missing dates are replaced with another telemetered value if available, or replaced with interpolated values and marked `POSITION_QC = '8'`.

**Pressure, Temperature, Salinity**

Delayed-mode quality control of `PRES` and `TEMP` is done by subjective assessment of vertical profile plots of `TEMP` vs `PRES` and `PSAL` vs `PRES` and `PRES` vs `TEMP` and `PSAL` vs `TEMP`. This assessment is done in relation to measurements from the same float, as well as in relation to nearby floats and historical data. This assessment aims to identify: (a) erroneous data points that cannot be detected by real-time QC tests, and (b) vertical profiles that have the wrong shape.

Bad `PRES` data points identified by visual inspection from delayed-mode analysts are recorded with `PRES_ADJUSTED_QC = '4'` and `PRES_QC = '4'`. For these bad data points, `TEMP_ADJUSTED_QC`, `TEMP_QC`, `PSAL_ADJUSTED_QC`, and `PSAL_QC` are also set to '4'.

Bad `TEMP` data points are recorded with `TEMP_ADJUSTED_QC = '4'` and `TEMP_QC = '4'`. `TEMP_ADJUSTED`, `TEMP_ADJUSTED_QC`, `TEMP_ADJUSTED_ERROR` are filled even when the data is good and no adjustment is needed. In these cases, `TEMP_ADJUSTED_ERROR` can be the manufacturer's quoted accuracy at deployment, which is 0.002 ÂºC.

Delayed-mode quality control of PSAL is done by checking for sensor offsets and drifts, as well as other instrument errors. Float salinity values that are considered adjustable in delayed-mode are compiled into time-series. Sufficiently long time-series are compared with statistical recommendations and uncertainties to check for sensor drift and offset.

After assessing all available information, the PI records `PSAL_ADJUSTED`, `PSAL_ADJUSTED_QC`, and `PSAL_ADJUSTED_ERROR`. Salinity data considered bad and unadjustable in delayed-mode are given `PSAL_ADJUSTED_QC = '4'`, and `PSAL_ADJUSTED` and `PSAL_ADJUSTED_ERROR` are set to FillValue.

**Oxygen**

Raw `DOXY` values are adjusted in delayed-mode to account for sensor drift and bias. The errors associated with this calibration are recorded in `DOXY_ADJUSTED_ERROR` in Âµmol kg^-1^.

When `DOXY` for the whole profile is bad and cannot be adjusted, then `DOXY_ADJUSTED = 99999.f`, `DOXY_ADJUSTED_ERROR = 99999.f`, and `DOXY_ADJUSTED_QC = '4'`. The calibration information is recorded as `SCIENTIFIC_CALIB_EQUATION = 'none'`, `SCIENTIFIC_CALIB_EQUATION = 'none'`, and `SCIENTIFIC_CALIB_COMMENT = 'Bad data; not adjustable'`.

**pH**

The pH adjustment process depends on having an accurate model for pH below 1000 m, where temporal and spatial variability is minimal. pH values are adjusted using Multiple Linear Regression (MLR) methods, Linearly Interpolated Regression equations, and a neural network prediction system known as CANYON. The expected error in float pH measurements is derived from the uncertainty in the reference data as well as sensor uncertainties.

The empirical algorithms used in the adjustment process for pH are:

the MLR method of Williams et al. (2016)

the LIR method of Carter et al. (2018)

the CANYON method of Sauzede et al. (2017)

The method used for adjustment is recorded in `SCIENTIFIC_CALIB_EQUATION`, `SCIENTIFIC_CALIB_COEFFICIENT`, and `SCIENTIFIC_CALIB_COMMENT`

**Quality control manuals**

*CTD data quality control: <https://archimer.ifremer.fr/doc/00228/33951/32470.pdf> (<http://dx.doi.org/10.13155/33951>***)**

*Oxygen data quality control: <https://archimer.ifremer.fr/doc/00354/46542/82301.pdf> (<http://dx.doi.org/10.13155/46542>*)

*pH data quality control: <https://archimer.ifremer.fr/doc/00460/57195/61336.pdf> (<https://doi.org/10.13155/57195>)*

*BGC data quality control: <https://archimer.ifremer.fr/doc/00298/40879/42267.pdf> (<http://dx.doi.org/10.13155/40879>)*
